<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring事务用法详解]]></title>
    <url>%2F2019%2F04%2F29%2Fspring-transaction-use%2F</url>
    <content type="text"><![CDATA[1. 数据库事务基础知识在使用Spring开发过程中，我们常会使用到Spring事务管理，它提供了灵活方便的事务管理功能，但这些功能都是基于底层数据库本身的事务处理机制功工作的。因此欲深入了解Spring事务的管理和配置，有必要先了解下数据库基本的事务知识。 1.1. 事务特性（ACID）Spring事务中存在四种特性：原子性、一致性、隔离性和持久性。在这些事务特性中，数据“一致性”为最终目标，其他特性都是为实现这个目标方法和手段。数据库一般采用重执行日志保证原子性、一致性和持久性，采用数据库锁机制保证事务的隔离性。 原子性（Atomicity）：将一个事务中的多个数据库操作捆绑成一个不可分割的原子单元。即对于一个事务的操作，要么全部执行，要么全部不执行。只有当整个事务的所有操作都执行成功，才会提交，否则即使整个事务中只要有一个操作失败，就算是已执行的操作也都必须都回滚到初始状态。 一致性（Consitency）：当事务完成时，必须保证所有数据都处于一致状态，即数据不会被破坏。如从A账户转账100元到B账户，无论操作是否成功，A和B的存款总额总是不变的。 隔离性（Isolation）：在并发操作数据时，不同的事务会有不同的数据操作，且它们的操作不会相互干扰。数据库规定了多种隔离级别，隔离级别越低，并发性越好，干扰越大会导致数据一致性变差；而隔离性越高，并发性越差，数据一致性越好。 持久性（Durability）：一旦事务成功完成提交后，整个事务的数据都会持久化到数据库中，且结果不受系统错误影响，即使系统崩溃，也可通过某种机制恢复数据。 1.2. 数据并发问题数据库中某块数据可能会同时被多个并发事务同时访问，若没有采取必要的隔离措施，可能会导致各种并发问题，破坏数据完整性。这些问题主要如下： 脏读（Dirty Read）：A事务读取到B事务尚未提交的更改数据，并在此基础上操作（B可能回滚）。比如，B事务取款操作会将账户上的余额进行更改且尚未提交，此时A事务查询到B事务尚未提交的账户余额，然后B事务回滚，账号余额恢复到更改之前，而A事务读取到的仍是B事务更改后的金额，若A事务在此基础上做操作，则会导致数据“变脏”。 不可重复读（Unrepeatable Read）：A事务先后读取同一条记录，在两次读取之间该条记录被B事务修改并提交，则会导致A事务两次读取的数据不同。比如，A事务先查询账户余额，在下次读取之前，此时B事务卡在中间修改了账户余额并提交，然后A事务在读取账户余额时会发现两次读取金额不一致。 幻读（Phantom Read）：A事务先后按相同查询条件去读取数据，在两次读取之间被B事务插入了新的满足条件的数据并提交，则会导致A事务两次读取的结果不同。比如，A事务按条件去查询当前账户中已绑定的卡情况，在下次查询之前，此时B事务卡在中间对该账户新增一张卡，然后A事务在按相同条件查询时，会发现多了一张卡。 1.3. 事务隔离级别事务隔离级别分为四种，如下： 读未提交（Read Uncommitted）：可以读取到未提交的数据。当一个事务已经写入一行数据但未提交，此时其他事务可以读到这个尚未提交的数据。 读已提交（Read Committed）：不可以读取到未提交的数据，只能读到已提交的数据。 重复读（Repeatable Read）：保证多次读取的数据都是一致的。 串读（Serializable）：最严格的事务隔离级别，不允许事务并行执行，只允许串行执行。事务执行时，如读操作和写操作都会加锁，好似事务就是以串行方式执行。 不同事务隔离级别能够解决数据并发问题的能力是不同的，具体对应关系如下所示： 隔离级别脏读不可重复读幻读Read Uncommitted√（允许）√√Read Committed×（不允许）√√Repeatable Read××√Serializable××× 2. 代码验证简述下面将以具体代码实例来演示Spring事务中@Transactional的每个参数的使用情况，代码结构主要分为Service和Dao层，由Spring负责依赖注入和注解式事务管理，Dao层由Mybatis实现，分别配置了双数据源Oracle和MySQL，其中Oracle对应的事务管理器限定符为oracleTM，MySql对应的为mysqlTM。当使用Spring事务注解@Transactional且未指定value（事务管理器）时，将会以默认的事务管理器来处理（以加载顺序，首先加载的作为默认事务管理器）。 Oracle和MySql分别新增了两张相同的表：T_SERVER1和T_SERVER2。这两张表的结构完全一致，共有2个字段：ID（varchar(32) not null primary key）和NAME（varchar(50)）。 Bean层：因为所有表结构都一致，故采用同一个Bean——Server类。 12345678910public class Server &#123; private String id; private String name; public Server() &#123; &#125; public Server(String name) &#123; this.name = name; &#125; // 省略get和set方法...&#125; Dao层： Dao层代码分为Oracle和MySQL对应的Mapper接口，Oracle对应的Mapper接口（Server1OracleDao接口和Server2OracleDao接口）为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Server1 Dao（基于Oracle） */public interface Server1OracleDao &#123; /** * 向T_SERVER1中插入一条新数据，其中主键id为32位sys_guid * @param server */ @Insert("insert into T_SERVER1 values (sys_guid(),#&#123;name&#125;)") void save(Server server); /** * 查询T_SERVER1中的所有数据 * @return */ @Select("select * from T_SERVER1") List&lt;Server&gt; getAllServers(); /** * 根据主键id，查询T_SERVER1中的数据 * @Options注解能够设置缓存信息 * useCache = true，表示会缓存本次查询结果 * flushCache = Options.FlushCachePolicy.FALSE，表示查询时不刷新缓存 * timeout = 10000，表示查询结果缓存10000秒 * @param id * @return */ @Options(useCache = false, flushCache = Options.FlushCachePolicy.TRUE) @Select("select * from T_SERVER1 where id=#&#123;id&#125;") Server getServerById(@Param("id") String id); /** * 根据主键id，更新T_SERVER1中的name * @param name * @param id */ @Update("update T_SERVER1 set name=#&#123;name&#125; where id=#&#123;id&#125;") void updateServerNameById(@Param("name") String name, @Param("id") String id);&#125;/** * Server2 Dao（基于Oracle） */public interface Server2OracleDao &#123; /** * 向T_SERVER2中插入一条新数据，其中主键id为32位sys_guid * @param server */ @Insert("insert into T_SERVER2 values (sys_guid(),#&#123;name&#125;)") void save(Server server);&#125; MySQL对应的Mapper接口（Server1MysqlDao接口）为：1234567891011/** * Server2 Dao（基于Oracle） */public interface Server2OracleDao &#123; /** * 向T_SERVER2中插入一条新数据，其中主键id为32位sys_guid * @param server */ @Insert("insert into T_SERVER2 values (sys_guid(),#&#123;name&#125;)") void save(Server server);&#125; Service层：具体Service层代码将视不同情况来分别列举，下面将详述。 3. Spring事务-传播行为（propagation）Spring事务大多特性都是基于底层数据库的功能来完成的，但是Spring的事务传播行为却是Spring凭借自身框架来实现的功能，它是Spring框架独有的事务增强特性。所谓事务传播行为就是指多个事务方法相互调用时，事务如何在这些方法间传播。Spring提供了七种事务传播行为，下面将详解每一种传播行为。 事务传播行为类型 说明 PROPAGATION_REQUIRED 表示当前方法必须运行在事务中。若当前没有事务，则新建一个事务，若已经存在于一个事务中，则加入到这个事务中。这是最常见的选择。 PROPAGATION_REQUIRES_NEW 表示当前方法必须运行在它自己的事务中。总是会启动一个新的事务，若当前没有事务，则新建一个事务，若已经存在于一个事务中，则会将当前事务挂起。 PROPAGATION_NESTED 表示当前方法运行于嵌套事务中。若已经存在于一个事务中，则会在嵌套事务中运行（相当于子事务），且子事务不会影响父事务和其他子事务，但是父事务会影响其所有子事务；若当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 PROPAGATION_SUPPORTS 表示当前方法不需要事务上下文。如果当前没有事务，就以非事务方式执行，若已经存在于一个事务中，则加入到这个事务中。 PROPAGATION_NOT_SUPPORTED 表示当前方法不应该运行在事务中。总是以非事务方式运行，若已经存在于一个事务中，则会将当前事务挂起。 PROPAGATION_MANDATORY 表示当前方法必须在事务中运行。总是想以事务方式运行，若已经存在于一个事务中，则加入到这个事务中，若当前没有事务，则会抛出异常。 PROPAGATION_NEVER 表示当前方法不应该运行于事务上下文中。总是不想以事务方式运行，若已经存在于一个事务中，则会抛出异常，若当前没有事务，则以非事务方式运行。 验证Spring事务传播行为的Service层接口和实现类、验证Spring事务传播的两个Service类、以及测试方法为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * spring事务传播行为 测试接口 */public interface iTransactionPropagation &#123; // 具体接口方法，下面将分情况描述...&#125;/** * spring事务传播行为 测试实现类 */@Servicepublic class TransactionPropagationImpl implements iTransactionPropagation &#123; /** * Server1 service */ @Autowired private iServer1Service server1Service; /** * Server2 service */ @Autowired private iServer2Service server2Service; /** * Server1 dao（基于Oracle） */ @Resource private Server1OracleDao server1OracleDao; /** * Server2 dao（基于Oracle） */ @Resource private Server2OracleDao server2OracleDao; // 具体接口实现方法，下面将分情况描述...&#125;/** * Server1接口（验证Spring事务传播） */public interface iServer1Service &#123; // 具体接口实现方法，下面将分情况描述...&#125;/** * Server1实现类（验证Spring事务传播） */@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; /** * Server1 Dao（基于Oracle） */ @Resource private Server1OracleDao server1OracleDao; // 具体接口实现方法，下面将分情况描述...&#125;/** * Server2接口（验证Spring事务传播） */public interface iServer2Service &#123; // 具体接口实现方法，下面将分情况描述...&#125;/** * Server2实现类（验证Spring事务传播） */@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; /** * Server2 Dao（基于Oracle） */ @Resource private Server2OracleDao server2OracleDao; // 具体接口实现方法，下面将分情况描述...&#125;/** * 测试类：Spring事务传播行为 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath*:/META-INF/spring/applicationContext.xml"&#125;)public class TransactionPropagationTest &#123; /** * Spring事务传播行为测试类 */ @Autowired private iTransactionPropagation transactionPropagation; // 具体测试方法，下面将分情况描述...&#125; 这里针对的是不同service类之间方法的调用。 3.1. PROPAGATION_REQUIRED为Server1Service和Server2Service的相应方法加上Propagation.REQUIRED属性。1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; // 省略其他... /** *有事务（传播行为=REQUIRED） * @param server */ @Override @Transactional(propagation = Propagation.REQUIRED) public void saveRequired(Server server) &#123; server1OracleDao.save(server); &#125;&#125;@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; // 省略其他... /** * 有事务（传播行为=REQUIRED） * @param server */ @Override @Transactional(propagation = Propagation.REQUIRED) public void saveRequired(Server server) &#123; server2OracleDao.save(server); &#125; /** * 有事务（传播行为=REQUIRED），且存在异常 * @param server */ @Override @Transactional(propagation = Propagation.REQUIRED) public void saveRequiredException(Server server) &#123; server2OracleDao.save(server); throw new RuntimeException(); &#125;&#125; 具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.REQUIRED修饰的内部方法，以验证事务传播特性。 3.1.1. 外围方法未开启事务当外围方法未开启事务，两种验证方法及结果情况如下所示。由此可得出：外围方法未开启事务，Propagation.REQUIRED修饰的内部方法会启动一个新的事务，且开启的事务相互独立、互不干扰。1234567891011121314151617181920212223242526272829/**验证方法1： * 外围方法：未开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2方法：开启事务（传播行为=REQUIRED） * * 结果：“服务1”和“服务2”均插入。 * 外围方法未开启事务，server1方法和server2方法各自在自己的事务中独立运行，外围方法的异常不影响内部方法的插入。 */@Overridepublic void noTransactionException_required_required() &#123; server1Service.saveRequired(new Server("服务1")); server2Service.saveRequired(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：未开启事务 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常 * * 结果：“服务1”插入，“服务2”未插入。 * 外围方法未开启事务，server1方法和server2方法各自在自己的事务中独立运行， * 其中server2方法抛出异常只会回滚server2中操作，而server1方法不受影响。 */@Overridepublic void noTransaction_required_requiredException() &#123; server1Service.saveRequired(new Server("服务1")); server2Service.saveRequiredException(new Server("服务2"));&#125; 3.1.2. 外围方法开启事务当外围方法开启事务，三种验证方法及结果情况如下所示。由此可得出：外围方法开启事务，Propagation.REQUIRED修饰的内部方法会加入到外围方法的事务中，并与外围方法属于同一事务，只要一个方法回滚，整个事务均回滚。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/**验证方法1： * 外围方法：开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，server1方法和server2方法的内部事务均加入外围方法事务， * 外围方法抛出异常，外围方法和内部方法均回滚。 */@Override@Transactionalpublic void transactionException_required_required() &#123; server1Service.saveRequired(new Server("服务1")); server2Service.saveRequired(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，server1方法和server2方法的内部事务均加入外围方法事务， * server2方法的内部事务抛出异常，外围方法感知异常致使整体事务回滚。 */@Override@Transactionalpublic void transaction_required_requiredException() &#123; server1Service.saveRequired(new Server("服务1")); server2Service.saveRequiredException(new Server("服务2"));&#125;/**验证方法3： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2方法：开启事务（传播行为=REQUIRED），最后抛出异常，并被捕获 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，server1方法和server2方法的内部事务均加入外围方法事务， * server2方法的内部事务抛出异常并在外围方法中捕获，即使server2方法被catch不被外围方法感知，整个事务依然回滚。 * （同一事务中所有方法只要有一个感知到异常，整体事务都回滚） */@Override@Transactionalpublic void transaction_required_requiredExceptionTry() &#123; server1Service.saveRequired(new Server("服务1")); try &#123; server2Service.saveRequiredException(new Server("服务2")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.2. PROPAGATION_REQUIRES_NEW为Server1Service和Server2Service的相应方法加上Propagation.REQUIRES_NEW属性。1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; // 省略其他... /** * 有事务（传播行为=REQUIRES_NEW） * @param server */ @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void saveRequiresNew(Server server) &#123; server1OracleDao.save(server); &#125; &#125;@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; // 省略其他... /** * 有事务（传播行为=REQUIRES_NEW） * @param server */ @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void saveRequiresNew(Server server) &#123; server2OracleDao.save(server); &#125; /** * 有事务（传播行为=REQUIRES_NEW），且存在异常 * @param server */ @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void saveRequiresNewException(Server server) &#123; server2OracleDao.save(server); throw new RuntimeException(); &#125;&#125; 具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.REQUIRES_NEW修饰的内部方法，以验证事务传播特性。 3.2.1. 外围方法未开启事务当外围方法未开启事务，两种验证方法及结果情况如下所示。由此可得出：外围方法未开启事务，Propagation.REQUIRES_NEW修饰的内部方法会启动一个新的事务，且开启的事务相互独立、互不干扰。123456789101112131415161718192021222324252627/**验证方法1： * 外围方法：未开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=REQUIRES_NEW） * -&gt;server2方法：开启事务（传播行为=REQUIRES_NEW） * * 结果：“服务1”和“服务2”均插入。 * 外围方法未开启事务，server1和server2分别会启动自己的事务独立运行，即使外围方法抛出异常，也不会影响内部方法（不会回滚）。 */@Overridepublic void noTransactionException_requiresNew_requiresNew() &#123; server1Service.saveRequiresNew(new Server("服务1")); server2Service.saveRequiresNew(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：未开启事务 * -&gt;server1方法：开启事务（传播行为=REQUIRES_NEW） * -&gt;server2方法：开启事务（传播行为=REQUIRES_NEW），最后抛出异常 * * 结果：“服务1”插入，“服务2”未插入。 * 外围方法未开启事务，server1和server2分别会启动自己的事务独立运行，其中server2方法中抛出异常会回滚，但不会影响server1的。 */@Overridepublic void noTransaction_requiresNew_requiresNewException() &#123; server1Service.saveRequiresNew(new Server("服务1")); server2Service.saveRequiresNewException(new Server("服务2"));&#125; 3.2.2. 外围方法开启事务当外围方法开启事务，三种验证方法及结果情况如下所示。由此可得出：外围方法开启事务，Propagation.REQUIRES_NEW修饰的内部方法仍会启动一个新的事务，且与外围方法事务和内部方法事务之间均相互独立、互不干扰。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/**验证方法1： * 外围方法：开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2.1方法：开启事务（传播行为=REQUIRES_NEW） * -&gt;server2.2方法：开启事务（传播行为=REQUIRES_NEW） * * 结果：“服务1”未插入，“服务2.1”和“服务2.2”均插入。 * 外围方法开启事务，server1与外围方法是同一事务，而server2.1和server2.2是分别新建的独立事务， * 当外围方法抛出异常时，与外围方法是同一事务的server1会回滚，但server2.1和server2.2不会回滚。 */@Override@Transactionalpublic void transactionException_required_requiresNew_requiresNew() &#123; server1Service.saveRequired(new Server("服务1")); // 与外围方法是同一事务，会回滚 server2Service.saveRequiresNew(new Server("服务2.1")); // 新建事务，不会回滚 server2Service.saveRequiresNew(new Server("服务2.2")); // 新建事务，不会回滚 throw new RuntimeException();&#125;/**验证方法2： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2.1方法：开启事务（传播行为=REQUIRES_NEW） * -&gt;server2.2方法：开启事务（传播行为=REQUIRES_NEW），最后抛出异常 * * 结果：“服务1”未插入，“服务2.1”插入，“服务2.2”未插入。 * 外围方法开启事务，server1与外围方法是同一事务，而server2.1和server2.2是分别新建的独立事务， * 当server2.2抛出异常时，server2.2的事务会回滚，外围方法也会感知到异常，server1也会回滚， * 而server2.1在新建的独立事务中，不会回滚。 */@Override@Transactionalpublic void transaction_required_requiresNew_requiresNewException() &#123; server1Service.saveRequired(new Server("服务1")); // 与外围方法是同一事务，会回滚 server2Service.saveRequiresNew(new Server("服务2.1")); // 新建事务，不会回滚 server2Service.saveRequiresNewException(new Server("服务2.2")); // 新建事务，会回滚&#125;/**验证方法3： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2.1方法：开启事务（传播行为=REQUIRES_NEW） * -&gt;server2.2方法：开启事务（传播行为=REQUIRES_NEW），最后抛出异常，并捕获 * * 结果：“服务1”插入，“服务2.1”插入，“服务2.2”未插入。 * 外围方法开启事务，server1与外围方法是同一事务，而server2.1和server2.2是分别新建的独立事务， * 当server2.2抛出异常时，server2.2的事务会回滚，外围方法catch住了这个异常，故server1不会回滚， * server2.1在新建的独立事务中，也不会回滚。 */@Override@Transactionalpublic void transaction_required_requiresNew_requiresNewExceptionTry() &#123; server1Service.saveRequired(new Server("服务1")); // 与外围方法是同一事务，不会回滚 server2Service.saveRequiresNew(new Server("服务2.1")); // 新建事务，不会回滚 try &#123; server2Service.saveRequiresNewException(new Server("服务2.2")); // 新建事务，会回滚 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.3. PROPAGATION_NESTED为Server1Service和Server2Service的相应方法加上Propagation.NESTED属性。1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; // 省略其他... /** * 有事务（传播行为=NESTED） * @param server */ @Override @Transactional(propagation = Propagation.NESTED) public void saveNested(Server server) &#123; server1OracleDao.save(server); &#125;&#125;@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; // 省略其他... /** *有事务（传播行为=NESTED） * @param server */ @Override @Transactional(propagation = Propagation.NESTED) public void saveNested(Server server) &#123; server2OracleDao.save(server); &#125; /** *有事务（传播行为=NESTED），且存在异常 * @param server */ @Override @Transactional(propagation = Propagation.NESTED) public void saveNestedException(Server server) &#123; server2OracleDao.save(server); throw new RuntimeException(); &#125;&#125; 具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.NESTED修饰的内部方法，以验证事务传播特性。 3.3.1. 外围方法未开启事务当外围方法未开启事务，两种验证方法及结果情况如下所示。由此可得：外围方法未开启事务，Propagation.PROPAGATION_NESTED和Propagation.PROPAGATION_REQUIRED作用相同，修饰内部的方法分别会启动自己的事务，且启动的事务相互独立、互不干扰。12345678910111213141516171819202122232425262728/**验证方法1： * 外围方法：未开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=NESTED） * -&gt;server2方法：开启事务（传播行为=NESTED） * * 结果：“服务1”和“服务2”均插入。 * 外围方法未开启事务，server1和server2分别在自己的事务中独立运行，外围方法的异常不影响内部方法的插入。 */@Overridepublic void noTransactionException_Nested_Nested() &#123; server1Service.saveNested(new Server("服务1")); server2Service.saveNested(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：未开启事务 * -&gt;server1方法：开启事务（传播行为=NESTED） * -&gt;server2方法：开启事务（传播行为=NESTED），最后抛出异常 * * 结果：“服务1”插入，“服务2”未插入。 * 外围方法未开启事务，server1和server2分别在自己的事务中独立运行， * 其中server2中抛出异常，其事务会回滚，但是不会影响server1的事务。 */@Overridepublic void noTransaction_Nested_NestedException() &#123; server1Service.saveNested(new Server("服务1")); server2Service.saveNestedException(new Server("服务2"));&#125; 3.3.2. 外围方法开启事务当外围方法开启事务，三种验证方法及结果情况如下所示。由此可得：外围方法开启事务，Propagation.PROPAGATION_NESTED修饰的内部方法属于外围事务的子事务，外围父事务回滚，则其所有子事务都回滚，若其中一个子事务回滚，则不会影响外围父事务和其他内部事务。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/**验证方法1： * 外围方法：开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=NESTED） * -&gt;server2方法：开启事务（传播行为=NESTED） * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，内部事务是外围事务的子事务，外围方法抛出异常，导致其子事务（server1和server2）也需要回滚。 */@Override@Transactionalpublic void transactionException_Nested_Nested() &#123; server1Service.saveNested(new Server("服务1")); server2Service.saveNested(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=NESTED） * -&gt;server2方法：开启事务（传播行为=NESTED），最后抛出异常 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，内部事务是外围事务的子事务，内部方法server2中抛出异常，使得server2会回滚， * 而外围方法可以感知到异常，会使其所有子事务都回滚，故而server1也会回滚。 */@Override@Transactionalpublic void transaction_Nested_NestedException() &#123; server1Service.saveNested(new Server("服务1")); server2Service.saveNestedException(new Server("服务2"));&#125;/**验证方法3： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=NESTED） * -&gt;server2方法：开启事务（传播行为=NESTED），最后抛出异常，并捕获 * * 结果：“服务1”插入，“服务2”未插入。 * 外围方法开启事务，内部事务是外围事务的子事务，内部方法server2中抛出异常，使得server2会回滚， * 而外围方法由于catch住了异常，无法感知到异常，故而server1不会回滚。 */@Override@Transactionalpublic void transaction_Nested_NestedExceptionTry() &#123; server1Service.saveNested(new Server("服务1")); try &#123; server2Service.saveNestedException(new Server("服务2")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 【注1】：Spring事务传播行为中PROPAGATION_REQUIRED、PROPAGATION_REQUIRES_NEW和PROPAGATION_NESTED的区别？REQUIRED是默认的事务传播行为。 REQUIRED、REQUIRES_NEW和NESTED这3种传播行为在修饰内部方法时，若外围方法无事务，都会新建一个新事务，且事务之间相互独立、互不干扰。 当外围方法有事务情况，REQUIRED和NESTED修饰的内部方法都属于外围方法事务，若外围方法抛出异常，都会回滚。但是，REQUIRED是加入外围事务，与外围方法属于同一事务，不管谁抛出异常，都会回滚；而NESTED是属于外围事务的子事务，有单独的保存点（savepoint），被NESTED修饰的内部方法（子事务）抛出异常会回滚，但不会影响到外围方法事务。 无论外围方法是否有事务，REQUIRES_NEW和NESTED修饰的内部方法抛出异常都不会影响到外围方法事务。当外围方法有事务情况，由于NESTED是嵌套事务，其修饰的内部方法为子事务，一旦外围方法事务回滚，会影响其所有子事务都回滚；而由于REQUIRES_NEW修饰的内部方法为启动一个新事务来实现的，故而内部事务和外围事务相互独立，外围事务回滚并不会影响到内部事务。 3.4. PROPAGATION_SUPPORTS为Server1Service和Server2Service的相应方法加上Propagation.SUPPORTS属性。1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; // 省略其他... /** * 有事务（传播行为=SUPPORTS） * @param server */ @Override @Transactional(propagation = Propagation.SUPPORTS) public void saveSupports(Server server) &#123; server1OracleDao.save(server); &#125;&#125;@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; // 省略其他... /** * 有事务（传播行为=SUPPORTS） * @param server */ @Override @Transactional(propagation = Propagation.SUPPORTS) public void saveSupports(Server server) &#123; server2OracleDao.save(server); &#125; /** * 有事务（传播行为=SUPPORTS），且存在异常 * @param server */ @Override @Transactional(propagation = Propagation.SUPPORTS) public void saveSupportsException(Server server) &#123; server2OracleDao.save(server); throw new RuntimeException(); &#125;&#125; 具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.SUPPORTS修饰的内部方法，以验证事务传播特性。 3.4.1. 外围方法未开启事务当外围方法未开启事务，两种验证方法及结果情况如下所示。由此可得出：外围方法未开启事务，Propagation.SUPPORTS修饰的内部方法以非事务方式运行，即使出现异常，也不会回滚。123456789101112131415161718192021222324252627/**验证方法1： * 外围方法：未开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=SUPPORTS） * -&gt;server2方法：开启事务（传播行为=SUPPORTS） * * 结果：“服务1”和“服务2”均插入。 * 外围方法未开启事务，server1和server2以非事务方式运行，外围方法抛出的异常不会影响server1和server2。 */@Overridepublic void noTransactionException_Supports_Supports() &#123; server1Service.saveSupports(new Server("服务1")); server2Service.saveSupports(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：未开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=SUPPORTS） * -&gt;server2方法：开启事务（传播行为=SUPPORTS），最后抛出异常，并捕获 * * 结果：“服务1”和“服务2”均插入。 * 外围方法未开启事务，server1和server2以非事务方式运行，即使server2中抛出异常，server1和server2都不会回滚。 */@Overridepublic void noTransaction_Supports_SupportsException() &#123; server1Service.saveSupports(new Server("服务1")); server2Service.saveSupportsException(new Server("服务2"));&#125; 3.4.2. 外围方法未开启事务当外围方法开启事务，三种验证方法及结果情况如下所示。由此可得出：外围方法开启事务，Propagation.SUPPORTS修饰的内部方法会加入外围事务，任一事务回滚，整个事务均会回滚。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/**验证方法1： * 外围方法：开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=SUPPORTS） * -&gt;server2方法：开启事务（传播行为=SUPPORTS） * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，server1和server2加入外围事务，当外围方法抛出异常，server1和server都会回滚。 */@Override@Transactionalpublic void transactionException_Supports_Supports() &#123; server1Service.saveSupports(new Server("服务1")); server2Service.saveSupports(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=SUPPORTS） * -&gt;server2方法：开启事务（传播行为=SUPPORTS），最后抛出异常 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，server1和server2加入外围事务，其中server2中抛出异常，影响所有事务都回滚。 */@Override@Transactionalpublic void transaction_Supports_SupportsException() &#123; server1Service.saveSupports(new Server("服务1")); server2Service.saveSupportsException(new Server("服务2"));&#125;/**验证方法3： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=SUPPORTS） * -&gt;server2方法：开启事务（传播行为=SUPPORTS），最后抛出异常，并捕获 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，server1和server2加入外围事务，其中server2抛出异常，虽然在外围方法中catch住了，所有事务仍会都回滚。 */@Override@Transactionalpublic void transaction_Supports_SupportsExceptionTry() &#123; server1Service.saveSupports(new Server("服务1")); try &#123; server2Service.saveSupportsException(new Server("服务2")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.5. PROPAGATION_NOT_SUPPORTED为Server1Service和Server2Service的相应方法加上Propagation.NOT_SUPPORTED属性。1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; // 省略其他... /** * 有事务（传播行为=NOT_SUPPORTED） * @param server */ @Override @Transactional(propagation = Propagation.NOT_SUPPORTED) public void saveNotSupported(Server server) &#123; server1OracleDao.save(server); &#125;&#125;@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; // 省略其他... /** * 有事务（传播行为=NOT_SUPPORTED） * @param server */ @Override @Transactional(propagation = Propagation.NOT_SUPPORTED) public void saveNotSupported(Server server) &#123; server2OracleDao.save(server); &#125; /** * 有事务（传播行为=NOT_SUPPORTED），且存在异常 * @param server */ @Override @Transactional(propagation = Propagation.NOT_SUPPORTED) public void saveNotSupportedException(Server server) &#123; server2OracleDao.save(server); throw new RuntimeException(); &#125;&#125; 具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.NOT_SUPPORTED修饰的内部方法，以验证事务传播特性。 3.5.1. 外围方法未开启事务当外围方法未开启事务，两种验证方法及结果情况如下所示。由此可得出：外围方法未开启事务，Propagation.NOT_SUPPORTED修饰的内部方法以非事务方式运行，不会被影响而回滚。12345678910111213141516171819202122232425/**验证方法1： * 外围方法：未开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=SUPPORTS） * * 结果：“服务1”插入。 * 外围方法未开启事务，server1以非事务方式运行，即使外围方法抛出异常，也不会回滚。 */@Overridepublic void noTransactionException_notSuppored() &#123; server1Service.saveNotSupported(new Server("服务1")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：未开启事务 * -&gt;server1方法：开启事务（传播行为=NOT_SUPPORTED） * -&gt;server2方法：开启事务（传播行为=NOT_SUPPORTED），且抛出异常 * * 结果：“服务1”和“服务2”均插入。 * 外围方法未开启事务，被NOT_SUPPORTED修饰的server1和server2，即使server2中抛出异常，server1和server2都会以非事务方式运行，不会回滚。 */@Overridepublic void noTransaction_notSuppored_notSupporedException() &#123; server1Service.saveNotSupported(new Server("服务1")); server2Service.saveNotSupportedException(new Server("服务2"));&#125; 3.5.2. 外围方法开启事务当外围方法开启事务，两种验证方法及结果情况如下所示。由此可得出：外围方法开启事务，Propagation.NOT_SUPPORTED修饰的内部方法以非事务方式运行，不会被影响而回滚。12345678910111213141516171819202122232425262728293031/**验证方法1： * 外围方法：开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2方法：开启事务（传播行为=NOT_SUPPORTED） * * 结果：“服务1”未插入，“服务2”插入。 * 外围方法开启事务，server1加入外围事务，server2以非事务方式运行， * 当外围方法抛出异常时，server1会回滚，server2不受影响。 */@Override@Transactionalpublic void transactionException_required_notSuppored() &#123; server1Service.saveRequired(new Server("服务1")); // 与外围事务同事务，会回滚 server2Service.saveNotSupported(new Server("服务2")); // 非事务，不会回滚 throw new RuntimeException();&#125;/**验证方法2： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=REQUIRED） * -&gt;server2方法：开启事务（传播行为=NOT_SUPPORTED），最后抛出异常 * * 结果：“服务1”未插入，“服务2”插入。 * 外围方法开启事务，server1加入外围事务，server2以非事务方式运行， * 其中server2中抛出异常，但server2不会回滚，而外围方法会感知到异常，影响server1会回滚。 */@Override@Transactionalpublic void transaction_required_notSupporedException() &#123; server1Service.saveRequired(new Server("服务1")); // 与外围事务同事务，会回滚 server2Service.saveNotSupportedException(new Server("服务2")); // 非事务，不会回滚&#125; 3.6. PROPAGATION_MANDATORY为Server1Service和Server2Service的相应方法加上Propagation.MANDATORY属性。1234567891011121314151617181920212223242526272829303132333435363738@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; // 省略其他... /** * 有事务（传播行为=MANDATORY） * @param server */ @Override @Transactional(propagation = Propagation.MANDATORY) public void saveMandatory(Server server) &#123; server1OracleDao.save(server); &#125;&#125;@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; // 省略其他... /** * 有事务（传播行为=MANDATORY） * @param server */ @Override @Transactional(propagation = Propagation.MANDATORY) public void saveMandatory(Server server) &#123; server2OracleDao.save(server); &#125; /** * 有事务（传播行为=MANDATORY），且存在异常 * @param server */ @Override @Transactional(propagation = Propagation.MANDATORY) public void saveMandatoryException(Server server) &#123; server2OracleDao.save(server); throw new RuntimeException(); &#125;&#125; 具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.MANDATORY修饰的内部方法，以验证事务传播特性。 3.6.1. 外围方法未开启事务当外围方法未开启事务，一种验证方法及结果情况如下所示。由此可得出：外围方法未开启事务，当外围方法调用Propagation.MANDATORY修饰的内部方法会抛出异常。123456789101112/**验证方法1： * 外围方法：未开启事务 * -&gt;server1方法：开启事务（传播行为=MANDATORY） * * 结果：“服务1”未插入。 * 外围方法未开启事务，外围方法调用server1时，会抛出异常 * （org.springframework.transaction.IllegalTransactionStateException: No existing transaction found for transaction marked with propagation 'mandatory'） */@Overridepublic void noTransaction_Mandatory() &#123; server1Service.saveMandatory(new Server("服务1"));&#125; 3.6.2. 外围方法开启事务当外围方法开启事务，三种验证方法及结果情况如下所示。由此可得出：外围方法开启事务，Propagation.MANDATORY修饰的内部方法会加入外围事务，任一事务回滚，整个事务均会回滚。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/**验证方法1： * 外围方法：开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=MANDATORY） * -&gt;server2方法：开启事务（传播行为=MANDATORY） * * 结果：“服务1”和“服务2”均未插入。 * 外围方法未开启事务，内部方法事务加入外围事务，外围方法抛出异常，server1和server2均会回滚。 */@Override@Transactionalpublic void transactionException_Mandatory_Mandatory() &#123; server1Service.saveMandatory(new Server("服务1")); server2Service.saveMandatory(new Server("服务2")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=MANDATORY） * -&gt;server2方法：开启事务（传播行为=MANDATORY），最后抛出异常 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法未开启事务，内部方法事务加入外围事务，其中server2中抛出异常，server2回滚，外围方法感知到异常，也会导致server1回滚。 */@Override@Transactionalpublic void transaction_Mandatory_MandatoryException() &#123; server1Service.saveMandatory(new Server("服务1")); server2Service.saveMandatoryException(new Server("服务2"));&#125;/**验证方法3： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=MANDATORY） * -&gt;server2方法：开启事务（传播行为=MANDATORY），最后抛出异常，并捕获 * * 结果：“服务1”和“服务2”均未插入。 * 外围方法开启事务，server1和server2加入外围事务，其中server2中抛出异常，虽然在外围方法中catch住了，所有事务仍会都回滚。 */@Override@Transactionalpublic void transaction_Mandatory_MandatoryExceptionTry() &#123; server1Service.saveMandatory(new Server("服务1")); try &#123; server2Service.saveMandatoryException(new Server("服务2")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 3.7. PROPAGATION_NEVER为Server1Service和Server2Service的相应方法加上Propagation.NEVER属性。12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class Server1ServiceImpl implements iServer1Service &#123; // 省略其他... /** * 有事务（传播行为=NEVER） * @param server */ @Override @Transactional(propagation = Propagation.NEVER) public void saveNever(Server server) &#123; server1OracleDao.save(server); &#125;&#125;@Servicepublic class Server2ServiceImpl implements iServer2Service &#123; // 省略其他... /** * 有事务（传播行为=NEVER） * @param server */ @Override @Transactional(propagation = Propagation.NEVER) public void saveNever(Server server) &#123; server2OracleDao.save(server); &#125; /** * 有事务（传播行为=NEVER），且存在异常 * @param server */ @Override @Transactional(propagation = Propagation.NEVER) public void saveNeverException(Server server) &#123; server2OracleDao.save(server); throw new RuntimeException(); &#125;&#125; 具体代码验证分为两种场景：一种是外围方法未开启事务，另一种是外围方法开启事务，这两种会调用Propagation.NEVER修饰的内部方法，以验证事务传播特性。 3.7.1. 外围方法未开启事务当外围方法未开启事务，两种验证方法及结果情况如下所示。由此可得：外围方法未开启事务，当外围方法调用Propagation.NEVER修饰的内部方法，内部方法会以非事务方式运行，不会被影响而回滚。12345678910111213141516171819202122232425/**验证方法1： * 外围方法：未开启事务，最后抛出异常 * -&gt;server1方法：开启事务（传播行为=NEVER） * * 结果：“服务1”插入。 * 外围方法未开启事务，server1以非事务方式运行，即使外围方法抛出异常，也不受影响，不会回滚。 */@Overridepublic void noTransactionException_never() &#123; server1Service.saveNever(new Server("服务1")); throw new RuntimeException();&#125;/**验证方法2： * 外围方法：未开启事务 * -&gt;server1方法：开启事务（传播行为=NEVER） * -&gt;server2方法：开启事务（传播行为=NEVER），最后抛出异常 * * 结果：“服务1”和“服务2”均插入。 * 外围方法未开启事务，server1和server2均以非事务方式运行，即使server2中抛出异常，也不受影响，均不会回滚。 */@Overridepublic void noTransaction_never_neverException() &#123; server1Service.saveNever(new Server("服务1")); server2Service.saveNeverException(new Server("服务2"));&#125; 3.7.2. 外围方法开启事务当外围方法开启事务，一种验证方法及结果情况如下所示。由此可得：外围方法开启事务，当外围方法调用Propagation.NEVER修饰的内部方法，会抛出异常。12345678910111213/**验证方法1： * 外围方法：开启事务 * -&gt;server1方法：开启事务（传播行为=NEVER） * * 结果：“服务1”未插入。 * 外围方法开启事务，当调用被NEVER修饰的server1内部方法时，会抛出异常 * （org.springframework.transaction.IllegalTransactionStateException: Existing transaction found for transaction marked with propagation 'never'）。 */@Override@Transactionalpublic void transaction_never() &#123; server1Service.saveNever(new Server("服务1"));&#125; 4. Spring事务-隔离级别（isolation）当多个事务同时操作同一数据库的记录时，这就会涉及并发控制和数据库隔离性问题了，其中隔离级别是数据库的事务特性ACID的一部分。Spring事务定义的隔离级别共有5个：DEFAULT、READ_UNCOMMITTED、READ_COMMITTED、REPEATABLE_READ和SERIALIZABLE。下面将详述每种隔离级别。 4.1. DEFAULTSpring默认隔离级别，使用后端数据库默认的隔离级别。大多数数据库默认的事务隔离级别是Read committed，比如Sql Server、Oracle，MySQL的默认隔离级别是Repeatable read。 4.2. READ_UNCOMMITTED读未提交：允许脏读，也就是一个事务可以读取到其他事务未提交的记录。隔离性最弱，并发性最高。见下图（MySQL环境），事务B更新数据后且尚未提交，事务A能读取到事务B未提交的数据“server1”，但是之后事务B回滚，此时事务A再次读取到的数据为之前的旧数据“服务1”，因此事务A读取到的数据就不是有效的，这种情况称为脏读。除了脏读，还会存在不可重复读和幻读的问题。需要注意的是，当我们基于Oracle数据库来通过Spring设置隔离级别为READ_UNCOMMITTED和REPEATABLE_READ时会有问题，具体如下：12345678910111213141516/**READ_UNCOMMITTED（读未提交）[Oracle]：A事务可以读取到B事务未提交的事务记录（B事务可能回滚）。 * 隔离性最低、并发性最好。存在脏读、不可重复读和幻读问题。 * * Oracle支持READ COMMITTED和SERIALIZABLE这两种事务隔离级别，默认为READ COMMITTED。 * 若以Isolation.READ_UNCOMMITTED或Isolation.REPEATABLE_READ访问，则会抛出如下异常： * org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; * nested exception is java.sql.SQLException: 仅 READ_COMMITTED 和 SERIALIZABLE 是有效的事务处理级 */@Override@Transactional(value = "oracleTM", isolation = Isolation.READ_UNCOMMITTED)public void readUncommittedByOracle() &#123; System.out.println("开始 READ_UNCOMMITTED[Oracle]..."); List&lt;Server&gt; serverList = serverOracleDao.getAllServers(); System.out.println("serverList: " + serverList); System.out.println("结束 READ_UNCOMMITTED[MySQL]...");&#125; 当使用基于Oracle且设置隔离级别为READ_UNCOMMITTED和REPEATABLE_READ时，会抛出异常：org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; nested exception is java.sql.SQLException: 仅 READ_COMMITTED 和 SERIALIZABLE 是有效的事务处理级。这是因为，Oracle不支持READ_UNCOMMITTED和REPEATABLE_READ这两种事务隔离级别，支持READ_COMMITTED和SERIALIZABLE，默认隔离级别为READ_COMMITTED。 4.3. READ_COMMITTED读已提交：一个事务只能读取到已经提交的记录，不能读取到未提交的记录。因此，脏读问题不会再出现，但可能出现其他问题。READ_COMMITTED解决了脏读问题。见下图（MySQL环境），事务B更新数据后且未提交，此时事务A读取到的是旧数据，接着事务B提交后，事务A再次读取到的是新数据，两次读取到的数据不一致，这种情况称为不可重复读。除了不可重复读问题，还存在幻读问题。 下面事务执行过程中，事务A设置为Read Committed并开始事务，当事务A查询某个id时，事务B可以直接更新指定id而无需等待，说明查询操作不会加锁；当事务A更新指定id时，事务B会出现等待，直至事务A提交后才会执行更新操作，说明更新操作会加锁。 4.4. REPEATABLE_READ重复读：一个事务可以多次从数据库读取某条记录，而且多次读取的那条记录都是一致的。REPEATABLE_READ解决了脏读和不可重复读问题。见下图（MySQL环境），在事务A前两次查询之间，事务B更新和插入数据并自动提交，发现事务A两次读取数据一致。这是因为，MySQl的存储引擎InnoDB通过多版本并发控制（MVCC，Multi-Version Concurrency Control）机制解决了该问题，实现了同一事务中多次读取某条记录（即使这条记录被其他事务更新或插入）的结果始终保持一致。但是，当事务A尚未提交，并插入id为’333’的数时，提示插入失败显示主键重复，说明该记录已存在。当事务A提交后，在以相同条件进行查询，可以发现事务B更新和插入后的数据。 4.5. SERIALIZABLE串读：事务执行时，会在涉及数据上加锁，强制事务排序，使之不会相互冲突。隔离性最强，并发性最弱。见下图（MySQL环境），事务A隔离级别设置为Serializable，并查询表中id为’111’的数据，该操作将会锁住被读取行数据，当事务B尝试去更新表中id为’111’的数据时，会一直等待，直至事务A提交，才会执行更新操作；而当事务B去更新id为’222’的数据时，不受影响，直接更新完，即不同行锁不会相互影响。 下面串行事务中，事务A隔离级别设置为Serializable，并查询整个表的数据，将会对整个表加锁，因此当事务B进行更新操作或者插入操作时，都将进入等待，直至事务A提交，才能开始进行操作。 5. Spring事务-超时（timeout）Spring事务参数timeout为超时时间，默认值为-1，指没有超时限制。如果超过设置的超时时间，事务还没有完成的话，则会抛出事务超时异常TransactionTimedOutException，并回滚事务。在下面的事务超时测试示例中，事务超时时间设置为2秒。在saveServer1_saveServer2_sleep()方法中，sleep操作（为了模拟超时场景）放在两个保存操作之后，在执行完两个保存之后出现超时情况，此时由结果可知，两个保存操作均插入。在saveServer1_sleep_saveServer2()方法中，sleep操作放在两个保存操作之间，在执行完第一个保存之后出现超时情况，此时由结果可知，两个保存操作均未插入。结论：Spring事务超时 = 事务开始时到最后一个Statement创建时时间 + 最后一个Statement的执行时超时时间（即其queryTimeout）。如下代码中，事务超时区间为事务开始到第二个保存操作，之后的操作超时将不会引起事务回滚。因此，当设置了超时参数，需要考虑到重要的操作不要放到最后执行，或是在操作最后加上一个无关紧要的Statement操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * Spring超时测试 实现类 */@Servicepublic class TimeoutImpl implements iTimeout &#123; @Resource private Server1OracleDao server1Dao; @Resource private Server2OracleDao server2Dao; /** * 超时时间设置为2（单位为秒，默认为-1，表示无超时无限制）。 * 执行顺序为：saveServer1 --&gt; saveServer2 --&gt; sleep 5 秒 * 结果：“服务1”和“服务2”均插入。 * 事务没有因为超时而回滚（事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。） * 原因：Spring事务超时 = 事务开始时到最后一个Statement创建时时间 + 最后一个Statement的执行时超时时间（即其queryTimeout）。所以在在执行Statement之外的超时无法进行事务回滚。 * @throws InterruptedException */ @Override @Transactional(timeout = 2, rollbackFor = Exception.class) public void saveServer1_saveServer2_sleep() throws InterruptedException &#123; System.out.println("\n开始保存 Server1..."); server1Dao.save(new Server("服务1")); System.out.println("结束保存 Server1..."); System.out.println("\n开始保存 Server2..."); server2Dao.save(new Server("服务2")); System.out.println("结束保存 Server2..."); System.out.println("\n开始等待..."); Thread.sleep(5000); System.out.println("结束等待..."); &#125; /** * 超时时间设置为2（单位为秒）。 * 执行顺序为：saveServer1 --&gt; sleep 5 秒 --&gt; saveServer2 * 结果：“服务1”和“服务2”均未插入。 * 事务成功回滚，抛出事务超时异常org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Thu Apr 25 11:39:06 CST 2019 * 总结：重要的操作不要放到最后一个Statement后面，尽量放到Statement中间，或是在操作后加上一个无关紧要的Statement操作。 * @throws InterruptedException */ @Override @Transactional(timeout = 2, rollbackFor = Exception.class) public void saveServer1_sleep_saveServer2() throws InterruptedException &#123; System.out.println("\n开始保存 Server1..."); server1Dao.save(new Server("服务1")); System.out.println("结束保存 Server1..."); System.out.println("\n开始等待..."); Thread.sleep(5000); System.out.println("结束等待..."); System.out.println("\n开始保存 Server2..."); server2Dao.save(new Server("服务2")); System.out.println("结束保存 Server2..."); &#125;&#125; 6. Spring事务-只读（readOnly）Spring的只读事务readOnly参数设置为true时，说明当前方法没有增改删的操作，Spring会优化这个方法，即使用了一个只读的connection，效率会高很多。建议使用场景为：当前方法查询量较大，且确保不会出现增改删情况；防止当前方法会出现增改删操作。在如下示例中可知，设置为只读事务，基于MySQl执行保存操作会抛出异常，而基于Oracle执行保存操作则成功插入，不受readOnly参数影响。Spring的只读事务并不是一个强制指令，它相当于一个提醒，提醒数据库当前事务为只读事务，不包含增改删操作，那么数据库则可能会根据情况进行一些特定的优化，如不考虑加相应的锁，减轻数据库的资源消耗。当然，并不是所有的数据库都支持只读事务，默认情况下在设置只读参数后，Oracle依旧可以进行增改删操作。1234567891011121314151617181920212223242526272829303132333435/** * Spring事务只读测试 实现类 */@Servicepublic class ReadOnlyImpl implements iReadOnly &#123; /** * Server1 dao（基于Oracle） */ @Resource private Server1OracleDao server1OracleDao; /** * Server1 dao（基于MySQL） */ @Resource private Server1MysqlDao server1MysqlDao; /** * 基于MySQL - 只读 * 执行保存操作失败，会报错。 * ### Error updating database. Cause: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed */ @Override @Transactional(value = "mysqlTM", readOnly = true) public void saveServerByMysql() &#123; server1MysqlDao.save(new Server("服务1")); &#125; /** * 基于Oracle - 只读 * 执行保存操作成功，不受只读设置影响。 */ @Override @Transactional(value = "oracleTM", readOnly = true) public void saveServerByOracle() &#123; server1OracleDao.save(new Server("服务1")); &#125;&#125; 7. Spring事务-回滚规则（rollbackFor、rollbackForClassName、noRollbackFor、noRollbackForClassName）Spring事务的回滚规则，如rollbackFor、rollbackForClassName、noRollbackFor和noRollbackForClassName，指定了遇到什么异常进行回滚，或者遇到什么异常不回滚。 rollbackFor：设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。（默认为RuntimeException）。 rollbackForClassName：设置需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，则进行事务回滚。 noRollbackFor：设置不需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，不进行事务回滚。 noRollbackForClassName：设置不需要进行回滚的异常类名称数组，当方法中抛出指定异常名称数组中的异常时，不进行事务回滚。 这些回滚规则均可指定单一异常类或者多个异常类，如： rollbackFor和noRollbackFor指定单一异常类形式为：@Transactional(rollbackFor=RuntimeException.class)，@Transactional(noRollbackFor=RuntimeException.class) rollbackFor和noRollbackFor指定多个异常类形式为：@Transactional(rollbackFor={RuntimeException.class, Exception.class})，@Transactional(noRollbackFor={RuntimeException.class, Exception.class}) rollbackForClassName和noRollbackForClassName指单一异常类名称形式为：@Transactional(rollbackForClassName=&quot;RuntimeException&quot;)，@Transactional(noRollbackFor=&quot;RuntimeException&quot;) rollbackForClassName和noRollbackForClassName指多个异常类名称形式为：@Transactional(rollbackForClassName={&quot;RuntimeException&quot;, &quot;Exception&quot;})，@Transactional(noRollbackFor={&quot;RuntimeException&quot;, &quot;Exception&quot;}) 参考资料[1] 陈雄华. Spring 3.x 企业应用开发实战[M]. 电子工业出版社. 2012.[2] Spring事务传播行为详解. https://segmentfault.com/a/1190000013341344#articleHeader14.[3] Spring事务隔离级别简介及实例解析. https://www.jb51.net/article/134466.htm.[4] MySQL的四种事务隔离级别. https://www.cnblogs.com/huanongying/p/7021555.html.[5] Spring官方文档-事务. https://docs.spring.io/spring/docs/5.0.9.RELEASE/spring-framework-reference/data-access.html#transaction.[6] Spring事务采坑 —— timeout. https://blog.csdn.net/qq_18860653/article/details/79907984.[7] Spring 使用注解方式进行事务管理. https://www.cnblogs.com/younggun/p/3193800.html.]]></content>
      <categories>
        <category>Spring框架系列</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util集合（collection）之LinkedList源码分析（jdk1.8）]]></title>
    <url>%2F2019%2F04%2F18%2Fcollection-linkedlist-sourcecode%2F</url>
    <content type="text"><![CDATA[1. 简介LinkedList是基于双向链表实现。它是一种可以在任意位置进行高效地插入和移除操作的有序序列。LinkedList是线程不安全的，若需在多线程环境使用，主要方法有：① 使用List list = Collections.synchronizedList(new LinkedList(…))；② 使用ConcurrentLinkedQueue；③ 使用synchronized关键字。 LinkedList在jdk1.6时为带有头结点的双向循环链表，jdk1.7和jdk1.8为不带头结点的普通的双向链表，示意图如下： 从下图可以得知，LinkedList继承于AbstractSequentialList，实现了List、Deque、Cloneable、java.io.Serializable这些接口。 继承AbstractSequentialList抽象类，提供序列化访问，只支持按次序访问，不像AbstractList那样支持随机访问。 实现List接口，提供了List接口的所有方法实现。 实现Deque接口，使得LinkedList具有双端队列特质。 实现Cloneable接口，支持可拷贝，即覆盖了函数clone()。 实现java.io.Serializable接口，支持序列化。 2. 属性与存储模型2.1. 属性size1transient int size = 0; 实际元素个数，存放当前链表有多少个节点。 first1transient Node&lt;E&gt; first; 指向链表的第一个节点的引用。Invariant: (first == null &amp;&amp; last == null) || (first.prev == null &amp;&amp; first.item != null)。 last1transient Node&lt;E&gt; last; 指向链表的最后一个节点的引用。Invariant: (first == null &amp;&amp; last == null) || (last.next == null &amp;&amp; last.item != null)。 2.2. 存储模型Node为LinkedList的内部类，是实际存放元素的地方。12345678910private static class Node&lt;E&gt; &#123; E item; // 元素 Node&lt;E&gt; next; // 下一个节点 Node&lt;E&gt; prev; // 上一个节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 3. 构造方法LinkedList提供了二种方式的构造函数，分别如下： LinkedList() public LinkedList()：无参构造函数，构造一个空列表。12public LinkedList() &#123;&#125; LinkedList(Collection&lt;? extends E&gt; c) public LinkedList(Collection&lt;? extends E&gt; c)：构造一个包含指定集合的列表。1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); // 调用无参构造函数 addAll(c); // 将指定集合c添加至当前链表末尾&#125; 这里addAll(int index, Collection&lt;? extends E&gt; c)方法逻辑详见下面常用方法的分析，点击此处跳转。 4. 常用方法add(E e) public boolean add(E e)：添加指定值为e的节点至当前链表的尾部。123456789101112131415161718192021public boolean add(E e) &#123; linkLast(e); // 添加一个值为e的新节点至链表尾部 return true;&#125;// 添加一个新节点至链表末尾，并更新first和或last指向void linkLast(E e) &#123; // 记录原尾节点位置给l，且l为final类型，不可更改 final Node&lt;E&gt; l = last; // 生成一个新节点：前驱指向当前链表的尾节点，值为e，后继指向null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 更新last指向新节点newNode last = newNode; if (l == null) // 若l为null，说明刚添加的newNode为第一个节点，将first指向第一个节点newNode first = newNode; else // 若l非null，则将l的后继指向新节点newNode l.next = newNode; // 更新size加1 size++; // 更新modCount加1 modCount++;&#125; 整体流程：记录当前链表的last位置为l –&gt; 生成一个新节点（前驱指向链表尾节点，值为e，后继指向null） –&gt; 更新last指向新生成节点；若l为null，更新first指向新生成节点，否则，令链表中原尾节点指向新生成节点 –&gt; 更新size和modCount都加1 –&gt; 添加成功，返回true。 【注1】 LinkedList链表调用add(E e)方法添加新元素时结构变化过程以及示意图。LinkedList新增元素的示例代码如下：123List&lt;String&gt; list = new LinkedList&lt;&gt;();list.add("a");list.add("b"); 根据上述代码执行过程，具体结构变化示意图如下： add(int index, E element) public void add(int index, E element)：在指定位置index插入一个值为element的新节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public void add(int index, E element) &#123; // 检查待插位置index是否越界[0,size] checkPositionIndex(index); if (index == size) // 若待插位置index为链表尾部，则调用linkLast()插至末尾 linkLast(element); else // 若待插位置index非链表尾部，则调用linkBefore()插至中间 linkBefore(element, node(index));&#125;// 越界检查private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) // 如果index不在0~size范围，则抛出IndexOutOfBoundsException异常 throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;// 检查参数index是否处于一个有效的位置[0,size]private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;// 越界信息输出private String outOfBoundsMsg(int index) &#123; return "Index: "+index+", Size: "+size;&#125;// 返回链表中index处的节点Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); // 判断index是否小于整个链表长度的一半（size&gt;&gt;1，右移1位，相当于size/2）， // 判断要插入的位置是距离链表头近还是链表尾近，找到原index处的节点并返回 if (index &lt; (size &gt;&gt; 1)) &#123; // 距离链表头近情况 Node&lt;E&gt; x = first; // 从头节点开始往后遍历，寻找index处的节点 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 距离链表尾近情况 Node&lt;E&gt; x = last; // 从尾节点往前遍历，寻找index处的节点 for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;// 在非空节点succ前插入一个值为e的新节点void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; // 记录succ的前驱指向 final Node&lt;E&gt; pred = succ.prev; // 生成一个新节点newNode：前驱指向pred指向的位置，值为e，后继指向succ（即新节点插在节点succ前面） final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // 令succ的前驱指向新节点newNode succ.prev = newNode; if (pred == null) // 若pred指向为null，说明新节点插在第一位，需更新first指向新节点newNode first = newNode; else // 若pred指向非空，更新pred的后继指向新节点newNode pred.next = newNode; // 更新size加1 size++; // 更新modCount加1 modCount++;&#125; 整体流程：检查待插位置index是否越界 –&gt; 若待插位置index等于链表中节点大小，则将新节点插入至链表末尾，否则插入至链表中间。这里插至尾部的方法为linkLast(E e)，前面add(E e)方法中已有详细分析，此处不再赘述；而插至中间的方法为linkBefore(E e, Node succ)，在插入之前需要调用node(int index)方法找到待插位置index的节点。【注2】 LinkedList中如何根据索引定位到指定节点数据？ 由于ArrayList基于数组可直接根据索引找到对应节点，而LinkedList基于链表，只有通过遍历才能找到对应的节点。为了更快速的找到index处的节点，通过判断index处于链表的前半段还是后半段，来决定是从头部往后遍历寻找还是从尾部往前遍历。linkBefore(E e, Node succ)执行流程为：记录节点succ（新节点将插在该节点前面）的前驱指向为pred –&gt; 生成一个新节点（前驱指向pred，值为e，后继指向succ） –&gt; 令succ的前驱指向新节点；若pred为null，更新first指向新生成节点，否则，令pred的后继指向新生成节点 –&gt; 更新size和modCount都加1。linkBefore(E e, Node succ)方法执行示意图如下： addAll(Collection&lt;? extends E&gt; c)和addAll(int index, Collection&lt;? extends E&gt; c) public boolean addAll(Collection&lt;? extends E&gt; c)：将指定集合c中的所有元素插入至当前链表末尾。 public boolean addAll(int index, Collection&lt;? extends E&gt; c)：将指定集合c插入链表中index处位置。addAll()有两个重载函数，其中addAll(Collection&lt;? extends E&gt; c)内部会调用addAll(int index, Collection&lt;? extends E&gt; c)，故此着重分析addAll(int index, Collection&lt;? extends E&gt; c)方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将集合c插至链表中size处位置，即插至尾部 return addAll(size, c);&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查待插位置index是否越界 checkPositionIndex(index); // 将参数集合c转为Object型数组 Object[] a = c.toArray(); // 令numNew为参数集合c的长度 int numNew = a.length; // 若待插集合c为空，则返回false if (numNew == 0) return false; // pred指向待插节点位置的前一个节点，succ指向待插节点位置的后一个节点 Node&lt;E&gt; pred, succ; if (index == size) &#123; // 若插至尾部，则令succ指向null，pred指向链表中的尾节点last succ = null; pred = last; &#125; else &#123; // 若插至中间，则令succ指向index处的节点，pred指向index处前一个节点 succ = node(index); pred = succ.prev; &#125; // 遍历集合中所有元素，使其按次序插入链表中 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; // 待插元素转型 // 新生成一个节点：前驱指向pred，值为e，后继指向null Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) // 若pred指向null，说明待插位置为首位节点，需更新first指向新节点 first = newNode; else // 若pred指向非null，则令pred的后继指向新节点 pred.next = newNode; // 移动pred指向新节点，使得下一个元素接着插入至当前新节点的后面 pred = newNode; &#125; if (succ == null) &#123; // 若是插入尾部，更新last指向pred last = pred; &#125; else &#123; // 若是插至中间，令参数集合c中最后一个元素生成的节点pred的后继指向succ，succ的前驱指向pred pred.next = succ; succ.prev = pred; &#125; // 更新size加参数集合c的长度 size += numNew; // 更新modCount加1 modCount++; return true;&#125; 整体流程：检查待插位置是否越界 –&gt; 将参数集合c转为Object型数组a，并获取数组长度给numNew –&gt; 若数组a长度为0，则返回false，否则继续执行插入操作 –&gt; 判断index与当前链表长度size是否相等，来决定pred和succ的指向（pred指向待插节点位置的前一个节点，succ指向待插节点位置的后一个节点） –&gt; 遍历待插所有元素，按次序分别生成新节点，并让新节点前驱指向前一个节点，前一个节点后继指向新节点 –&gt; 若succ指向null，则更新last指向最后一个节点，否则，插入的最后节点的后继与succ的前驱相互指向 –&gt; 更新size加上已插元素数以及modCount加1 –&gt; 所有元素插入成功，返回true。具体执行流程示意图如下所示： To Be continued! 参考资料]]></content>
      <categories>
        <category>java集合系列（java.util包）</category>
      </categories>
      <tags>
        <tag>java集合</tag>
        <tag>java.util.List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.util集合（collection）之ArrayList源码分析（jdk1.8）]]></title>
    <url>%2F2019%2F04%2F02%2Fcollection-arraylist-sourcecode%2F</url>
    <content type="text"><![CDATA[1. 简介ArrayList是基于数组实现，是一个可变大小的动态数组。ArrayList是线程不安全的，只可在单线程环境下使用，若需在多线程环境使用，主要方法有：① 通过Collections.synchronizedList(List list)方法返回一个线程安全的ArrayList类；② 使用java.util.concurrent.CopyOnWriteArrayList；③ 使用synchronized关键字。 从下图可以得知，ArrayList继承于AbstractList，实现了List、RandomAccess、Cloneable、java.io.Serializable这些接口。 继承AbstractList，实现List。定义了对数组的基本操作，如增加、删除、修改、遍历等。 实现RandomAccess，支持随机访问。RandmoAccess是List实现所使用的标记接口，使算法能够在随机和顺序访问List中性能更加高效。 实现Cloneable，支持可拷贝。Cloneable接口相当于标记接口，只有实现该接口的类，并在类中重写Object的clone方法，然后通过该类调用clone方法才能成功，若没有实现Cloneable接口，则会抛出CloneNotSupportedException异常。 实现java.io.Serializable，支序列化。Serializable接口为一个空接口，为实现该接口的对象提供标准的序列化与反序列化操作。 本文的涉及注解整理于此： 注[1]：ArrayList种的elementData属性为什么被transient修饰？ 注[2]：ArrayList(Collection&lt;? extends E&gt; c)构造函数里有这样一句注释：c.toArray might (incorrectly) not return Object[] (see 6260652) 注[3]：ArrayList在add时为什么扩容1.5倍？ 注[4]：ArrayList在add时存在线程安全性问题？ 注[5]：ArrayList的扩容机制（jdk1.8）？ 注[6]：Arrays.copyOf与System.arraycopy的区别？ 注[7]：为什么说ArrayList查询快，增删慢？ 注[8]：ArrayList中remove(Object o)方法可能无法删除对象问题？ 注[9]：ArrayList中removeAll和retainAll的区别？以及removeAll的具体操作图解。 注[10]：ArrayList使用toArray()转数组抛异常问题？如何正确转换为所需类型数组？ 注[11]：ArrayList中fail-fast机制？ArrayList使用iterator遍历时可能会抛出ConcurrentModificationException？ 2. 属性DEFAULT_CAPACITY1private static final int DEFAULT_CAPACITY = 10; 默认容量为10。当ArrayList初始化时没有指定大小时，则使用该缺省容量值。 EMPTY_ELEMENTDATA1private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; 共享常量空对象数组。当ArrayList构造方法显示指定初始容量为0时，会将EMPTY_ELEMENTDATA赋给elementData数组。 DEFAULTCAPACITY_EMPTY_ELEMENTDATA1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 共享常量空对象数组。当ArrayList构造方法没有显示指定初始容量时，会将DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给elementData数组。与EMPTY_ELEMENTDATA区别是：当第一个元素被加进来时，它知道如何扩容（用处在add(E e)中有体现）。 elementData1transient Object[] elementData; elementData为 “Object[]类型的数组”，是ArrayList中数据实际存储的地方。为什么说ArrayList底层是一个动态数组？ 我们可以通过带指定初始容量的构造函数ArrayList(int initialCapacity)来初始化elementData数组大小，或者通过不带参数的构造函数ArrayList()来创建默认容量为10的ArrayList。elementData数组的容量会随元素数据的增加而动态增大，具体动态增大方式可参考ensureCapacityInternal(int minCapacity)方法，下面也会对此方法进行解析。注[1]：ArrayList种的elementData属性为什么被transient修饰？当一个对象被序列化时，不会序列化被transient关键字修饰的变量的值。然而ArrayList又是可被序列化的类，作为存储实际数据的elementData数组，若无法进行序列化，那么在反序列化时ArrayList难道会丢失原先的数据？实际上，ArrayList在序列化的时候会调用writeObject(java.io.ObjectOutputStream s)，直接将size和element写入ObjectOutputStream；反序列化时调用readObject(java.io.ObjectInputStream s)，从ObjectInputStream获取size和element，再恢复到elementData。（私有的writeObject和readObject是通过反射被调用的：ObjectInputStream.readObject() --&gt; ObjectInputStream.readObject0() --&gt; 经过switch选择到TC_OBJECT，ObjectInputStream.readOrdinaryObject() --&gt; ObjectInputStream.readSerialData() --&gt; ObjectStreamClass.invokeReadObject(): readObjectMethod.invoke(obj, new Object[]{ in })反射调用ArrayList中的readObject()）之所以不直接对elementData序列化，而通过上述方式来实现序列化，是因为：elementData作为一个缓存数组，并不是所有地方都存储满了数据，而是预留一些容量，等需要时再扩容。由此可知数组中有些地方可能没有存储实际元素，通过上述方式实现序列化时，数组中只有实际存储的数据会被序列化，而不是整个数组中的数据，这样可以一定程度上降低空间和时间的消耗。 size1private int size; 动态数组的实际大小，ArrayList包含的元素数量。 3. 构造方法ArrayList提供了三种方式的构造函数，分别如下： ArrayList(int initialCapacity) public ArrayList(int initialCapacity)：构造一个指定初始容量的空ArrayList。12345678910111213public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 初始容量大于0时，创建指定初始容量的Object数组赋给elementData this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 初始容量等于0时，将EMPTY_ELEMENTDATA空对象数组赋给elementData this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 初始容量小于0时，抛出IllegalArgumentException异常 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; ArrayList() public ArrayList()：构造一个无参，使用默认容量为10的空ArrayList。1234public ArrayList() &#123; // 没有显示指定初始容量时，将DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给elementData this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; ArrayList(Collection&lt;? extends E&gt; c) public ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定Collection型的集合参数。123456789101112131415public ArrayList(Collection&lt;? extends E&gt; c) &#123; // 将Collection类型参数c转为数组赋给elementData elementData = c.toArray(); // 将转为数组的elementData的长度赋给size，并判断参数集合是否为空 if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) // 若参数集合非空但是没有成功转为Object数组，则复制数组并转为Object型数组 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. // 若参数集合为空，则将EMPTY_ELEMENTDATA赋给elementData this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 注[2]：ArrayList(Collection&lt;? extends E&gt; c)构造函数里有这样一句注释：c.toArray might (incorrectly) not return Object[] (see 6260652)，意思是c.toArray可能无法正确返回Object[]。可参见官方bug描述，bug编号为6260652。由上述源码可知，c.toArray()将参数集合转为数组并赋给elementData。若该数组非空，还需判断该数组类型是否为Object型数组，若不是，则需将该数组复制并转为Object型数组。由此，可说明c.toArray()可能返回非Object型数组，具体原因分析如下：123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; // test1: List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); list1.add("aaa"); list1.add("bbb"); Object[] objArr1 = list1.toArray(); System.out.println("objArr1: " + objArr1.getClass()); // objArr1: class [Ljava.lang.Object; // test2: List&lt;String&gt; list2 = new TestList&lt;&gt;(); Object[] objArr2 = list2.toArray(); System.out.println("objArr2: " + objArr2.getClass()); // objArr2: class [Ljava.lang.String; objArr2[0] = new Object(); // java.lang.ArrayStoreException: java.lang.Object &#125;&#125;class TestList&lt;E&gt; extends ArrayList&lt;E&gt; &#123; @Override public Object[] toArray() &#123; return new String[]&#123;"aaa", "bbb"&#125;; &#125;&#125; 测试1中，list1.toArray()会调用ArrayList自身的toArray()方法返回Object型数组。测试2中，list2.toArray()会调用TestList自身实现的toArray()方法返回String型数组，objArr2实际上是String[]类型，因为抽象类或接口的具体类型取决于实例化时所使用的子类类型。在执行objArr2[0] = new Object()时则会抛出异常，因为这种向下转型会存在安全性问题。总之，可能造成c.toArray返回非Object[]类型的原因是：toArray()方法可能会被覆盖重新实现，返回非Object[]类型。 4. 常用方法add(E e) public boolean add(E e)：将指定元素添加到列表尾部。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean add(E e) &#123; // size + 1：存多少个元素，就分配多少空间资源，保证不浪费空间资源 ensureCapacityInternal(size + 1); // Increments modCount!! // 添加新元素e到elementData的末尾，然后size自增1 elementData[size++] = e; return true;&#125;// 确认ArrayList的容量大小private void ensureCapacityInternal(int minCapacity) &#123; // 当elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则minCapacity取默认容量10和minCapacity的最大值 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;// 判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) &#123; // 操作数+1，该变量主要是用来实现fail-fast机制 modCount++; // overflow-conscious code // 若所需容量最小值&gt;实际数组的长度，则扩容数组 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;// 扩容操作private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 新容量newCapacity为旧容量oldCapacity（数组长度）的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // &gt;&gt;位运算右移1位相当于除以2 // 若扩充容量仍小于所需容量最小值（newCapacity&lt;minCapacity），则让新容量newCapacity等于所需容量最小值minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 若新容量newCapacity大于数组最大容量MAX_ARRAY_SIZE，则进行大容量重新分配 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: // 将原来的数据复制到新的数组，且新数组的容量为新容量newCapacity elementData = Arrays.copyOf(elementData, newCapacity);//Arrays.copyOf:返回一个新的长度的数组对象，拷贝了原数组中的元素&#125;// 根据所需容量最小值，重新计算容量值private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); // 若所需容量最小值minCapacity大于数组最大容量MAX_ARRAY_SIZE，则返回Integer最大值，否则返回数组最大容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 整体流程：确认ArrayList的容量（检查是否需要扩容，扩容方法为Arrays.copyOf()）（①若elementData为DEFAULTCAPACITY_EMPTY_ELEMENTDATA时，则取默认容量10；②正常扩充为原来1.5倍）–&gt; 将元素插入elementData数组指定位置–&gt; 将集合中实际容量加1，即size+1。 注[3]：ArrayList在add时为什么扩容1.5倍？ArrayList在扩容的时候既要考虑时间开销，还要考虑空间开销。其中，时间开销来自于申请新的内存和拷贝数组；空间开销来自于申请的空间多于需要的空间。从时间效率上来看，应尽量减少扩容的次数，一次扩充的越多越好；而从空间效率上来看，应尽量按需扩充，即需要多少元素就扩充多少容量。由此可知，这两个效率因素是互相矛盾的，需要平衡考虑。在实际中，时间效率的优先级别往往高于空间效率，故而，不可能一次扩容一个，而一次扩容50%，应该是兼顾各个因素的一个结果。 注[4]：ArrayList在add时存在线程安全性问题？ArrayList在执行add操作时，数据的更新主要分为两步来执行：①将元素插入elementData数组指定位置（elementData[size] = e）;②将集合中实际容量加1（size+1）。该过程不能保证在多线程环境下具有原子性，存在线程安全性问题。举例说明：假设在多线程环境下有两个线程A和B，线程A将元素放入elementData数组中索引为0的位置，此时线程A暂停。线程B开始运行，也向elementData数组中添加数据，而此时size为0，故而也会将数据插入索引为0的位置。接着，线程A和B都开始运行，都使size+1。现在来看，ArrayList中的实际元素只有1个，而size等于2，这就存在线程不安全了。 注[5]：ArrayList的扩容机制（jdk1.8）？ArrayList的扩容发生在add操作时，由上述源码分析可知，具体有以下几个阶段：①在add()方法中调用ensureCapacityInternal(size + 1)来确定扩容所需的最小容量值minCapacity。参数size+1是为了保证空间尽量不被浪费，是元素添加后的实际容量。若elementData为默认的空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，则取默认容量和size+1后容量的最大值作为minCapacity。②调用ensureExplicitCapacity(minCapacity)来确定是否需要扩容。首先将操作数modCount+1，然后判断minCapacity是否大于当前elementData数组的长度，若是，则说明需要进行扩容。③扩容方法调用grow(minCapacity)来实现。首先将原elementData数组长度增加1.5倍，若增加后的容量小于参数minCapacity，则将minCapacity赋给新容量newCapacity，否则新容量newCapacity为增加1.5倍后容量。然后判断新容量newCapacity若大于数组最大容量MAX_ARRAY_SIZE，则调用hugeCapacity(minCapacity)来重新分配。最后得到确定的新容量newCapacity，调用Arrays.copyOf(elementData, newCapacity)进行数据复制和扩容。 实际运行过程中，第一次扩充为默认容量10，当实际存储到第11个元素时，会扩充其1.5倍，为15。 add(int index, E element) public void add(int index, E element)：在指定位置index，插入一个新元素element。123456789101112131415161718192021public void add(int index, E element) &#123; // 检查待插位置index是否越界 rangeCheckForAdd(index); // 空间检查，按需扩容 ensureCapacityInternal(size + 1); // Increments modCount!! // 数组复制，复制过程相当于将数组中从index开始往后的所有数据都向后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;// 检查索引index是否越界，若大于size或小于0，则抛出IndexOutOfBoundsException异常private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;// java.lang.System#arraycopy：native方法// 复制指定源数组src到目标数组dest，复制从src的srcPos索引开始，复制的个数是length，复制到dest的索引从destPos开始。public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 整体流程：检查待插index是否越界 –&gt; 空间检查，按需扩容（等同于add(E e)方法中）–&gt; 扩容完，调用System.arraycopy()方法：从index起始到数组末尾，将所有元素往后移1位 –&gt; 将元素插入elementData数组指定位置 –&gt; 将集合中实际容量加1，即size+1。 注[6]：Arrays.copyOf与System.arraycopy的区别？Arrays.copyOf不只是复制数组元素，还创建了一个新的数组对象。 System.arrayCopy只复制已有的数组元素。Arrays.copyOf的内部实现是用的System.arraycopy：12345678910111213141516public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;/** * 在其内部创建了一个新的数组，然后调用System.arrayCopy()向其复制内容，返回出去。 */public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; // 创建一个newLength大小新的数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); // 将original内容复制到copy中去，并且长度为newLength System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 由上可知，System.arraycopy方法会因为新数组长度比旧数组长度小而报IndexOutOfBoundsException；而Arrays.copyOf则不会因此报错，因为Arrays.copyOf 的返回值是在内部new好的copy数组，而该copy数组new的大小就等于newLength。由此对System.arraycopy方法的描述，可知，ArrayList在随机位置进行插入（即调用add(int index, E element)方法）时，每次都会移动数组中的元素，随着数据量增大，花费的时间也必然会增加。这也就是常说的，ArrayList在插入时的效率比较差，不及LinkedList。 addAll(Collection&lt;? extends E&gt; c) public boolean addAll(Collection&lt;? extends E&gt; c)：将指定的集合c添加到列表尾部。12345678910111213public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 将参数集合c转为Object型数组 Object[] a = c.toArray(); int numNew = a.length; // 空间检查，按需扩容 // size+numNew：numNew为待添加集合长度，与当前数组size之和为所需最小容量值 ensureCapacityInternal(size + numNew); // Increments modCount // 将a数组的所有元素都复制到elementData中的尾部 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; // a数组长度非0（非空）时返回true，否则返回false return numNew != 0;&#125; 整体流程：将待添加集合c转为数组a –&gt; 空间检查，按需扩容 –&gt; 将a数组中所有元素复制到elementData数组尾部 –&gt; 将集合中实际容量增加a数组长度大小，即size+a.length。 addAll(int index, Collection&lt;? extends E&gt; c) public boolean addAll(int index, Collection&lt;? extends E&gt; c)：在指定位置index，插入集合c。1234567891011121314151617181920212223public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 待插index越界检查 rangeCheckForAdd(index); // 将参数集合c转为Object型数组 Object[] a = c.toArray(); // 待插数组c的长度，即需要后移的位数 int numNew = a.length; // 空间检查，按需扩容 ensureCapacityInternal(size + numNew); // Increments modCount // 计算需移动的元素数量 int numMoved = size - index; if (numMoved &gt; 0) // 将当前数组elementData中从index开始往后的所有元素都向后移动numNew位 System.arraycopy(elementData, index, elementData, index + numNew, numMoved); // 将待插数组a的所有元素复制到elementData数组中（从index位置开始） System.arraycopy(a, 0, elementData, index, numNew); size += numNew; // a数组长度非0（非空）时返回true，否则返回false return numNew != 0;&#125; 整体流程：检查待插index是否越界 –&gt; 将待添加集合c转为数组a –&gt; 空间检查，按需扩容 –&gt; 将当前数组elementData从index开始往后的所有元素向后移动待查数组a的长度 –&gt; 将待插数组a的所有元素复制到从index开始的elementData数组中 –&gt; 将集合中实际容量增加a数组长度大小，即size+a.length。 get(int index) public E get(int index)：获取index位置的元素。123456public E get(int index) &#123; // 检查参数index是否越界 rangeCheck(index); // 返回当前数组elementData中index位置的元素 return elementData(index);&#125; 整体流程：检查是否越界 –&gt; 获取当前数组elementData中index处的元素。 注[7]：为什么说ArrayList查询快，增删慢？查询快：由get(int index)方法源码可知，ArrayList底层为Object数组，在内存中是一片连续的空间，查询时可直接根据数组的首地址+偏移量访问到第index个元素在内存中的位置。增删慢：增删操作时，需要移动数组中的元素，随着数据量增大，花费的时间也必然会增加。其中增加操作尤指随机添加元素add(int index, E element)方法。 set(int index, E element) public E set(int index, E element)：替换指定位置index处的元素值为element。12345678910public E set(int index, E element) &#123; // 越界检查 rangeCheck(index); // 取出index处旧值赋给oldValue E oldValue = elementData(index); // 将elementData中index处元素值改为element elementData[index] = element; // 返回旧值 return oldValue;&#125; 整体流程：检查是否越界 –&gt; 记录index处旧值 –&gt; 替换index处为新值 –&gt; 返回旧值。 remove(int index) public E remove(int index)：移除指定位置index处的元素。123456789101112131415161718public E remove(int index) &#123; // 越界检查 rangeCheck(index); // 操作数+1 modCount++; // 取出index处旧值赋给oldValue E oldValue = elementData(index); // 需移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) // 将elementData数组中index后的所有元素都向前移动一位 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 消除过期对象的引用 elementData[--size] = null; // clear to let GC do its work // 返回旧值 return oldValue;&#125; 整体流程：检查是否越界 –&gt; 操作数+1，记录index处旧值 –&gt; 将elementData数组中index后的所有元素都向前移动一位 –&gt; 将集合中实际容量size减1 –&gt; 将数组最后1位设置为null，让GC回收。 remove(Object o) public boolean remove(Object o)：移除集合中第一次出现的对象o（若存在）。12345678910111213141516171819202122232425262728293031public boolean remove(Object o) &#123; // 移除操作根据参数对象o是否为空，分两种情况处理 if (o == null) &#123; // 若参数对象o为null for (int index = 0; index &lt; size; index++) // 遍历所有元素，判断是否为null，若是则移除 if (elementData[index] == null) &#123; fastRemove(index); return true; // 移除一次就返回 &#125; &#125; else &#123; // 若参数对象o为非null for (int index = 0; index &lt; size; index++) // 遍历所有元素，通过equals判断是否与参数对象o相等，若是则移除 if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;// 移除指定位置index的元素// 与remove(int index)基本一致，区别在于没有越界检查和返回旧值private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 整体流程：判断参数对象o是否为null，若为null –&gt; 遍历集合中所有元素，判断是否为null –&gt; 若找到为null的元素，则执行快速移除并返回true；若不为null –&gt; 遍历集合中所有元素，判断是否与参数对象o相等 –&gt; 若找到与o相等的元素，则执行快速移除并返回true。 注[8]：ArrayList中remove(Object o)方法可能无法删除对象问题？先看如下示例，list增加了3个TestObject对象后，再调用remove(Object o )方法进行删除，试想下打印结果是什么？123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; List&lt;TestObject&gt; list = new ArrayList&lt;&gt;(); list.add(new TestObject(1, "111")); list.add(new TestObject(2, "222")); list.add(new TestObject(3, "333")); list.remove(new TestObject(2, "222")); list.forEach(System.out::println); &#125;&#125;class TestObject &#123; private int index; private String value; TestObject(int index, String value) &#123; this.index = index; this.value = value; &#125; @Override public String toString() &#123; return "TestObject&#123;" + "index=" + index + ", value='" + value + '\'' + '&#125;'; &#125;&#125; 输出为：123TestObject&#123;index=1, value=&apos;111&apos;&#125;TestObject&#123;index=2, value=&apos;222&apos;&#125;TestObject&#123;index=3, value=&apos;333&apos;&#125; 这一项“{index=2, value=&#39;222&#39;}”并没有被删除，为什么呢？由remove(Object o )方法源码可知，ArrayList在删除对象时，需要先判断待删对象是否存在于集合元素中，这种判断时通过equals实现。而上述TestObject类使用的是默认Object类的equals方法，该默认方法是通过this == obj来判断两个对象是否为同一个对象，虽然上述示例中比较的两个对象的内的值都一样，但由于都是重新new创建的对象，所以这里equals比较时返回false。所以，当我们需要使用remove(Object o)方法时，需要对操作的类重写equals和hashCode方法。之所以还需要对hashCode方法进行重写，是因为若要对该操作类使用到HashMap或HashSet这类散列数据结构时，只重写equals没有重写hashCode的话会出错。也有相关规范提及：若两个对象经过equals比较后相同，那么它们的hashCode也一定相同，故而一般hashCode和euqals需要同时重写。重写euqals和hashCode后的TestObject类如下：1234567891011121314151617181920212223242526272829class TestObject &#123; private int index; private String value; TestObject(int index, String value) &#123; this.index = index; this.value = value; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; TestObject that = (TestObject) o; if (index != that.index) return false; return Objects.equals(value, that.value); &#125; @Override public int hashCode() &#123; int result = index; result = 31 * result + (value != null ? value.hashCode() : 0); return result; &#125; @Override public String toString() &#123; return "TestObject&#123;" + "index=" + index + ", value='" + value + '\'' + '&#125;'; &#125;&#125; 重写后，再执行上面程序，此时可以移除“{index=2, value=&#39;222&#39;}”，输出如下：12TestObject&#123;index=1, value=&apos;111&apos;&#125;TestObject&#123;index=3, value=&apos;333&apos;&#125; removeAll(Collection&lt;?&gt; c)和retainAll(Collection&lt;?&gt; c) public boolean removeAll(Collection&lt;?&gt; c)：移除当前集合中存在于指定参数集合c中的所有元素。 public boolean retainAll(Collection&lt;?&gt; c)：只保留当前集合中存在于指定参数集合c中的所有元素，换言之，移除当前集合中未存在于参数集合c中的所有元素。removeAll是用来去除在指定集合中的元素，可用于排除值；retainAll是用来去除不在指定集合中的元素，可用于取交集。之所以将这两个方法放一起说，是因为它门都调用了相同的方法batchRemove，这点体现出了代码复用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public boolean removeAll(Collection&lt;?&gt; c) &#123; // 判空，为空抛出空指针异常 Objects.requireNonNull(c); return batchRemove(c, false);&#125;public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125;// 检查参数对象obj是否为空，为空则抛出NullPointerException异常，否则返回该对象public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125;private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // r指读取计数，w指写入计数 int r = 0, w = 0; boolean modified = false; try &#123; // 遍历当前集合，①若参数集合c不包含elementData中某元素（即c.contains(elementData[r])为false，removeAll），则elementData保留该元素，否则，不保留该元素，即删除c中存在的元素； // ②若参数集合c包含elementData中某元素（即c.contains(elementData[r])为true，retainAll），则elementData保留该元素，否则，不保留该元素，即删除c中不存在的元素； for (; r &lt; size; r++) if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // Preserve behavioral compatibility with AbstractCollection, // even if c.contains() throws. // 为了保持和AbstractCollection的兼容性 // 若try中遍历未执行完而抛出异常，则r必然不等于size，此时为了最大程度保证数据一致性，会将后面还未比对的数据都保留下来 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); w += size - r; &#125; // [0,w)之间记录了需要保留的数据，从w开始往后的所有数据都要清空 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; // 操作数 + (size - w) modCount += size - w; // 集合实际容量为w size = w; modified = true; &#125; &#125; return modified;&#125;// 判断当前集合是否包含参数对象opublic boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;// 获取参数对象o在当前集合中首次出现的索引位置public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; // 返回-1，代表指定参数对象o不存在于当前集合中 return -1;&#125; 整体流程：removeAll：判空 –&gt; 遍历当前集合，若参数集合c不包含elementData中某元素，则保留该元素在elementData中 –&gt; 若r不等于size，则保留后面未比对的数据 –&gt; 清空从w开始往后的所有数据 –&gt; 操作数更新（modCount += size - w） –&gt; 集合容量更新（size=w）。retainAll：判空 –&gt; 遍历当前集合，若参数集合c包含elementData中某元素，则保留该元素在elementData中 –&gt; 若r不等于size，则保留后面未比对的数据 –&gt; 清空从w开始往后的所有数据 –&gt; 操作数更新（modCount += size - w） –&gt; 集合容量更新（size=w）。 注[9]：ArrayList中removeAll和retainAll的区别？以及removeAll的具体操作图解。具体区别及源码分析可见上述描述。removeAll方法的操作图解如下： clear() public void clear()：清除集合中的所有元素。12345678910public void clear() &#123; // 操作数+1 modCount++; // clear to let GC do its work // 遍历集合所有元素，然后将其设为null for (int i = 0; i &lt; size; i++) elementData[i] = null; // 将集合长度设为0 size = 0;&#125; 整体流程：操作数+1 –&gt; 遍历所有元素，并置为null –&gt; 设置集合大小为0。 trimToSize() public void trimToSize()：修剪掉预留元素。1234567891011public void trimToSize() &#123; // 操作数+1 modCount++; // 当集合实际长度size小于数组elementData长度时，才需要修剪下 if (size &lt; elementData.length) &#123; // 当集合实际长度size为0时，给elementData赋空数组，否则将elementData复制为一个新的长度为size的数组，修剪掉多余的容量 elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125;&#125; 整体流程：操作数+1 –&gt; 当集合实际长度size小于数组长度时，开始修剪 –&gt; 修剪：若集合长度size为0，则置为空数组，否则将数组elementData复制为一个长度为size的新数组。 toArray()和toArray(T[] a) public Object[] toArray()：将集合转为Object型数组。 public &lt;T&gt; T[] toArray(T[] a)：将集合转为所需要类型的数组。1234567891011121314151617public Object[] toArray() &#123; // 返回一个新的Object型数组，它的内容和长度与当前集合的内容一致 return Arrays.copyOf(elementData, size);&#125;public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: // 当参数数组长度小于当前数组实际长度，则直接返回一个内容和长度与elementData一致的新数组 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 当参数数组长度大于等于当前数组实际长度，则将当前数组elementData复制到新数组a上 System.arraycopy(elementData, 0, a, 0, size); // 若新数组长度大于当前数组实际长度，则将a[size]置为null if (a.length &gt; size) a[size] = null; // 返回新数组a return a;&#125; 注[10]：ArrayList使用toArray()转数组抛异常问题？如何正确转换为所需类型数组？当我们想要将集合List转为数组时，若使用如下的写法，则会报java.lang.ClassCastException异常。因为toArray()方法返回的Object类型数组，不能将Object[]转为String[]。123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("a");list.add("b");list.add("c");// java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;String[] array = (String[]) list.toArray(); 要想解决这种异常问题，可以通过遍历Object数组的所有元素，分别对这些元素进行强转，如下代码所示：12345Object[] arrayObj = list.toArray();for (int i = 0; i &lt; arrayObj.length; i++) &#123; String str = (String) arrayObj[i]; System.out.println(str);&#125; 当然更好的方法是采用toArray(T[] a)，代码示例如下：12345// 方法1：String[] arr = new String[list.size()];String[] arr1 = list.toArray(arr);// 方法2：String[] arr2 = list.toArray(new String[0]); 5. 遍历方式ArrayList支持3种遍历方式。123456789101112131415// 1.for循环遍历for (int i = 0; i &lt; list.size(); i++) &#123; String value = list.get(i); System.out.println(value);&#125;// 2.foreach遍历for (String s : list) &#123; System.out.println(s);&#125;// 3.iterator遍历Iterator&lt;String&gt; it = list.iterator();while (it.hasNext()) &#123; String value = it.next(); System.out.println(value);&#125; 注[11]：ArrayList中fail-fast机制？ArrayList使用iterator遍历时可能会抛出ConcurrentModificationException？fail-fast称为“快速失败”，它是Java集合中的一种错误机制。当使用iterator遍历集合过程中，倘若该集合的结构被修改，如ArrayList的add和remove方法，则有可能会抛出ConcurrentModificationException异常，从而产生fail-fast。具体fail-fast示例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748List&lt;Integer&gt; list = new ArrayList&lt;&gt;();// 初始化集合：先向集合中添加0,1,2,...,9共10个数字for (int i = 0; i &lt; 10; i++) &#123; list.add(i);&#125;/** * 单线程环境 */Iterator&lt;Integer&gt; it = list.iterator();int i = 0;Integer v;while (it.hasNext()) &#123; if (3 == i) &#123; list.remove(i); &#125; v = it.next(); System.out.println(v); i++;&#125;/** * 多线程环境 */// 一个线程通过iterator遍历集合new Thread(() -&gt; &#123; Iterator&lt;Integer&gt; it = list.iterator(); Integer v; while (it.hasNext()) &#123; v = it.next(); System.out.println(v + ","); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start();// 一个线程在i为3时，调用remove修改集合new Thread(() -&gt; &#123; int i = 0; while (10 &gt; i) &#123; if (3 == i) &#123; list.remove(i); &#125; i++; &#125;&#125;).start(); 以上分为单线程和多线程两种环境情况，分别执行都会抛出java.util.ConcurrentModificationException异常。产生这种异常，主要是因为在操作Iterator，下面分析下ArrayList中Iterator源码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... // 通过调用iterator()方法，new了一个ArrayList子类Itr（迭代器实现类） public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; // Itr是Iterator的实现类 private class Itr implements Iterator&lt;E&gt; &#123; // 下一个待返回的元素索引，默认为0 int cursor; // index of next element to return // 上一个已返回的元素索引，默认为-1 int lastRet = -1; // index of last element returned; -1 if no such // 对集合修改次数的期望值，初始值为modCount int expectedModCount = modCount; // 判断是否还存在下一个元素，若cursor等于集合大小size，则说明已到末尾 public boolean hasNext() &#123; return cursor != size; &#125; // 获取下一个元素值 @SuppressWarnings("unchecked") public E next() &#123; // 判断expectedModCount是否等于modCount，若不等于则说明集合结构已被修改，抛出ConcurrentModificationException checkForComodification(); int i = cursor; // 判断当前待返回元素下标是否大于等于集合大小size，若是，则说明待返回元素不存在，抛出NoSuchElementException if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 判断当前待返回元素下标是否大于等于集合长度，若是，则抛出ConcurrentModificationException if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // cursor自增1 cursor = i + 1; // 返回元素，并将lastRet重新赋值为刚返回元素的下标 return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = ArrayList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[i++]); &#125; // update once at end of iteration to reduce heap write traffic cursor = i; lastRet = i - 1; checkForComodification(); &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; ... &#125; 有上述源码分析可知，当调用Itr的next()和remove()时，都会执行checkForComodification()方法，若modCount不等于expectedModCount，则会抛出ConcurrentModificationException异常，这里才是产生fail-fast的根源。何时会导致modCount不等于expectedModCount？ 当ArrayList实例调用iterator()时，会返回一个新创建的iterator迭代器，其中expectedModCount初始化为当前集合中的modCount。当调用next()方法时会通过checkForComodification()方法去检查，若在调用next()前调用了集合中可能导致结构变化的方法（如add()和remove()）或是另一个线程修改了集合结构，导致集合中的modCount变化，从而致使expectedModCount不等于modCount，抛出ConcurrentModificationException异常。一言以蔽之，当调用iterator遍历集合过程中，若集合中modCount变化（调用集合的add()、remove()和clear()等方法），则会抛出ConcurrentModificationException异常，引发fail-fast。fail-fast是一种错误检测机制，但并不能保证该机制一定会被触发。若需使用可能引发fail-fast的集合，建议使用CopyOnWriteArrayList。 参考资料[1] Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例. http://www.cnblogs.com/skywang12345/p/3308556.html#a1.[2] ArrayList中elementData为什么被transient修饰？ https://blog.csdn.net/zero__007/article/details/52166306.[3] Java笔记—c.toArray might (incorrectly) not return Object[] (see 6260652)官方Bug. https://blog.csdn.net/gulu_gulu_jp/article/details/51457492.[4] jdk1.8ArrayList主要方法和扩容机制（源码解析）. https://blog.csdn.net/u010890358/article/details/80515284.[5] Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法). https://www.cnblogs.com/skywang12345/p/3308762.html.]]></content>
      <categories>
        <category>java集合系列（java.util包）</category>
      </categories>
      <tags>
        <tag>java集合</tag>
        <tag>java.util.List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架总述（java.util包）]]></title>
    <url>%2F2019%2F03%2F28%2Fcollection-frame-diagram%2F</url>
    <content type="text"><![CDATA[1. java.util中collection集合java.util下的集合框架主要基于Collection接口，它是最基本的集合接口，定义了集合的基本操作。Collection接口继承了Iterable接口，说明Collection的子类都可以实现遍历操作，通过Iterable接口中的 Iterator&lt;T> iterator() 方法可返回一个Iterator（迭代器）进行遍历，通常用法如下：1234Iterator it = collection.iterator(); // 获取集合的迭代器while(it.hasNext()) &#123; // 集合中是否还有元素 Object obj = it.next(); // 返回下一个元素&#125; 此外，java 8新增了forEach方法，也可实现遍历操作。 Collection接口下的子接口主要有：List（序列）、Set（集）和Queue（队列）。List的特点是元素有序、可重复的，其实现的常用集合类有ArrayList、LinkedList、Vector和Stack。 ArrayList：基于数组实现，线程不安全。查找快，增删慢。 LinkedList：基于链表实现，线程不安全。增删快，查找慢。 Vector：基于数组实现，线程安全。底层实现类似于ArrayList，区别是内部很多方法使用synchronized关键字来实现线程安全，效率低于ArrayList。不建议使用。 Stack：继承于Vector，实现了“栈”结构（LIFO，后进先出）。基于数组实现，线程安全。亦可通过ArrayDeque或LinkedList来实现“栈”结构。不建议使用。 Set的特点是元素无序、不可重复的，其实现的常用集合类有HashSet、LinkedHashSet和TreeSet。 HashSet：底层其实是固定value的HashMap。元素无序、线程不安全、不可重复、值可允许为Null。 LinkedHashSet：继承于HashSet，基于LinkedHashMap实现，使用链表来维护元素顺序。元素有序、线程不安全、不可重复、值可允许为Null。因为通过链表维护元素顺序，故而LinkedHashSet相较于HashSet在插入时性能稍逊而迭代访问时性能较好。 TreeSet：是SortedSet接口的实现类，基于TreeMap实现，可以确保集合中元素处于排序状态，它支持自然排序（默认）和定制排序（Comparator）。 Queue的特点是元素有序、可重复的，其实现的常用集合类有PriorityQueue、ArrayDeque和LinkedList。 PriorityQueue：一种基于优先级堆的极大优先级队列（基于数组的完全二叉树），是一个比较标准的队列实现类（FIFO，先进先出），区别于标准队列的地方是PriorityQueue是按照队列元素大小重新排序，而非入队顺序。它能保证每次取出的都是队列中权值最小的元素，其中默认排序为自然顺序排序（即升序排序），亦可通过Comparator来自定义排序方式。它不允许Null、可重复、线程不安全。 ArrayDeque：是Deque（双端队列，支持同时从两端添加或移除元素，亦可作LIFO队列（栈））接口的实现类 + 基于数组实现 = 基于循环数组实现的双端队列。查找快，增删慢，线程不安全。ArrayDeque可作栈来使用，效率高于Stack；亦可作队列使用，相对LinkedList更高效。 LinkedList：既实现了List接口，也实现了Deque接口，具备List、队列和栈的特性。 2. java.util中map集合 java.util下的Map主要特点是键值对的形式，一个key对应一个value，且key不可重复。其常用实现类有HashMap、LinkedHashMap、TreeMap、HashTable和weakHashMap等。 HashMap：jdk1.6/1.7采用位桶+链表实现，jdk1.8采用位桶+链表+红黑树实现。它允许key和value为Null，key不可重复，线程不安全，不保证key有序。 LinkedHashMap：是HashMap的子类，内部维护了一个双向链表，保存了记录的插入顺序。LinkedHashMap的遍历速度和实际数据有关，而HashMap是和容量有关。 TreeMap：是SortedMap接口的实现类，能够按key进行排序，它支持自然排序（默认）和定制排序（Comparator）。 HashTable：继承了Dictionary抽象类，与HashMap类似。不允许key或value为Null，线程安全（各个方法上增加synchronize关键字）。因为专门适用多线程场景的ConcurrentHashMap，故而不建议使用HashTable。 weakHashMap：和HashMap类似。它的键是“弱键”，key和value都可以是Null。它的特点是：当除了自身有对key引用外，此key没有其他引用情况，会在下次进行增删改查操作时丢弃该键值对，使该键被回收，节约内存，适用于需要缓存的场景。 EnumMap：专门为枚举类型定做的Map实现，它只能接收同一枚举类型的实例作为键值。它使用数组来存放与枚举类型对应的值，这种实现非常高效。不允许key为Null，但允许value为Null。 IdentityHashMap：利用Hash表来实现Map接口。它允许key重复，但是key必须是两个不同的对象。与HashMap不同的是，它重写了hashCode方法不是使用Object.hashCode()，而是System.identityHashCode()方法（根据对象在内存中的地址计算出来的一个数值）。 3. java.util.concurrent中集合To be continued… 参考资料[1] Java：集合，Collection接口框架图. https://www.cnblogs.com/nayitian/p/3266090.html.[2] 浅谈WeakHashMap. http://www.importnew.com/23182.html.[3] Java枚举（enum）详解：Java声明枚举类型、枚举（enum）类、EnumMap 与 EnumSet. http://c.biancheng.net/view/1100.html]]></content>
      <categories>
        <category>java集合系列（java.util包）</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一、Zookeeper简介、三种搭建模式和配置文件详解]]></title>
    <url>%2F2019%2F03%2F25%2Fone-zookeeper-deploy%2F</url>
    <content type="text"><![CDATA[table th:first-of-type { width: 100px; } 1. 简介Zookeeper缘起于非开源的Google的Chubby，雅虎模仿Chubby开发了ZooKeeper，实现了类似的分布式锁管理，并捐给了Apache，作为是Hadoop和Hbase的重要组件。ZooKeeper是一种用于分布式应用程序的分布式开源协调服务，它主要是用来解决分布式应用中经常遇到的一些数据一致性问题。它的一致性、可靠性和容错性保证了其能够在大型分布式系统中稳定的表现，并不会因为某一个节点服务宕机而导致整个集群崩溃。它可提供的功能包括：配置维护、域名服务、分布式同步、组服务等。Zookeeper集群中的角色主要有： Leader：为zk集群的核心，负责集群内部的调度、投票的发起和决策和系统状态更新登。 Follower：接收Client请求、转发请求给Leader和参与投票等。 Observer：充当观察者角色，功能与Follower基本一致，不同点在于它不参与任何形式的投票，它只提供非事务请求服务。 Zookeeper维护一个具有层次关系的数据结构，类似于文件系统，名称是由斜杠（/）分隔的路径元素序列，ZooKeeper名称空间中的每个节点都由路径标识。 2. 安装配置zookeeper的相关资源如下： 官网：http://zookeeper.apache.org/ 下载：https://archive.apache.org/dist/zookeeper/ zookeeper的安装之前，需确保java环境运行正常。zookeeper有三种搭建方式：单机模式、伪集群模式和集群模式。 2.1. 单机模式解压：将下载好的zookeeper-*.tar.gz解压到指定安装目录下：12tar -zxvf zookeeper-3.4.10.tar.gz #解压zookeeper压缩包cd zookeeper-3.4.10 #进入zookeeper根目录 主要目录结构： bin：一些执行脚本命令，其中，.sh为linux环境下脚本，.cmd为windows下脚本。 conf：存放配置文件和日志配置文件。 contrib：一些附加功能，用于操作zk的工具包。 dist-maven：mvn编译后目录。 docs：相关操作文档。 lib：zk依赖的jar包。 recipes：一些代码示例demo。 src：源文件。 配置文件：将conf目录下zoo_sample.cfg复制一份并重命名为zoo.cfg：1cp conf/zoo_sample.cfg conf/zoo.cfg 修改配置文件zoo.cfg：123456tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper/zookeeper-3.4.10/dataDir #zk数据保存目录dataLogDir=/usr/local/zookeeper/zookeeper-3.4.10/dataLogDir #zk日志保存目录，当不配置时与dataDir一致clientPort=2181 #客户端访问zk的端口 配置文件中参数详解见“3.配置文件详解”。 配置环境变量：为方便操作，可对zk配置环境变量，linux环境下在/etc/profile文件最后追加：123ZOOKEEPER_HOME=/usr/local/zookeeper/zookeeper-3.4.10PATH=$PATH:$ZOOKEEPER_HOME/binexport ZOOKEEPER_HOME PATH 为立即生效配置，通过执行如下命令：1source /etc/profile 启动zk服务：1zkServer.sh start 启动信息：123ZooKeeper JMX enabled by defaultUsing config: /usr/local/zookeeper/zookeeper-3.4.10/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 查看zk状态：1zkServer.sh status 输出状态信息：123ZooKeeper JMX enabled by defaultUsing config: /usr/local/zookeeper/zookeeper-3.4.10/bin/../conf/zoo.cfgMode: standalone #说明当前为单机模式 关闭zk服务：1zkServer.sh stop 关闭信息：123ZooKeeper JMX enabled by defaultUsing config: /usr/local/zookeeper/zookeeper-3.4.10/bin/../conf/zoo.cfgStopping zookeeper ... STOPPED 2.2. 伪集群模式zookeeper还可以在单机上运行多个zk实例，实现单机伪集群的搭建，即单机环境下模拟zk集群的运行。现在在单机上搭建一个3个节点的伪分布式环境，需要配置3个配置文件（zoo1.cfg、zoo2.cfg、zoo3.cfg，分别代表3个节点的配置信息）。在配置过程中，必须保证各个配置文件中的端口号（clientPort）不能冲突，zk数据及日志保存目录（dataDir、dataLogDir）也不能一样。除此之外，还需要在每个节点对应的dataDir中创建一个名为myid的文件，并写入一个数字以标识当前的zk实例。在一台单机上部署3个节点的伪集群模式的zookeeper环境，假设3台zk服务分别为server1、server2和server3，对应3个配置文件分别为zoo1.cfg、zoo2.cfg和zoo3.cfg，这些重点的配置文件信息描述如下：conf/zoo1.cfg：1234567891011tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper/zookeeper-3.4.10/cluster-data/dataDir1dataLogDir=/usr/local/zookeeper/zookeeper-3.4.10/cluster-data/dataLogDir1clientPort=2181#server.id=host:port1:port2,其中id为server id,对应myid;host为ip或主机名称;port1为用于followers连接到leader的端口; port2为leader选举时使用的端口.server.1=127.0.0.1:2287:3387server.2=127.0.0.1:2288:3388server.3=127.0.0.1:2289:3389 创建myid文件，并写入server id：1echo "1" &gt; cluster-data/dataDir1/myid conf/zoo2.cfg：1234567891011tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper/zookeeper-3.4.10/cluster-data/dataDir2dataLogDir=/usr/local/zookeeper/zookeeper-3.4.10/cluster-data/dataLogDir2clientPort=2182#server.id=host:port1:port2,其中id为server id,对应myid;host为ip或主机名称;port1为用于followers连接到leader的端口; port2为leader选举时使用的端口.server.1=127.0.0.1:2287:3387server.2=127.0.0.1:2288:3388server.3=127.0.0.1:2289:3389 创建myid文件，并写入server id：1echo "2" &gt; cluster-data/dataDir2/myid conf/zoo3.cfg：1234567891011tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper/zookeeper-3.4.10/cluster-data/dataDir3dataLogDir=/usr/local/zookeeper/zookeeper-3.4.10/cluster-data/dataLogDir3clientPort=2183#server.id=host:port1:port2,其中id为server id,对应myid;host为ip或主机名称;port1为用于followers连接到leader的端口; port2为leader选举时使用的端口.server.1=127.0.0.1:2287:3387server.2=127.0.0.1:2288:3388server.3=127.0.0.1:2289:3389 创建myid文件，并写入server id：1echo "3" &gt; cluster-data/dataDir3/myid 启动zk服务：1234567891011121314151617zkServer.sh start conf/zoo1.cfg#运行server1实例，输出信息如下：ZooKeeper JMX enabled by defaultUsing config: conf/zoo1.cfgStarting zookeeper ... STARTEDzkServer.sh start conf/zoo2.cfg#运行server2实例，输出信息如下：ZooKeeper JMX enabled by defaultUsing config: conf/zoo2.cfgStarting zookeeper ... STARTEDzkServer.sh start conf/zoo3.cfg#运行server3实例，输出信息如下：ZooKeeper JMX enabled by defaultUsing config: conf/zoo3.cfgStarting zookeeper ... STARTED 启动后，可通过jps命令，查看zk运行情况：123418866 QuorumPeerMain18967 Jps18936 QuorumPeerMain18894 QuorumPeerMain 其中，QuorumPeerMain为zk集群的启动入口类，用来加载配置启动QuorumPeer线程。 查看zk个节点状态：1234567891011121314151617zkServer.sh status conf/zoo1.cfg#查看server1状态，输出信息如下：ZooKeeper JMX enabled by defaultUsing config: conf/zoo1.cfgMode: followerzkServer.sh status conf/zoo2.cfg#查看server2状态，输出信息如下：ZooKeeper JMX enabled by defaultUsing config: conf/zoo2.cfgMode: leaderzkServer.sh status conf/zoo3.cfg#查看server3状态，输出信息如下：ZooKeeper JMX enabled by defaultUsing config: conf/zoo3.cfgMode: follower 从返回的状态信息可知，server2为leader、server1和server3为follower。 2.3. 集群模式在真实环境中，为提供可靠的zookeeper分布式环境，通常一台机器上只部署一个zk服务。在zk集群中，若超过半数以上的服务节点可用，则整个zk集群服务是可用的，故而其节点数通常为大于等于3的奇数（2n+1）。现在分别在3台机器上搭建zk分部署环境，3台机器情况如下： zk服务标识 ip myid server1 192.168.56.100 1 server2 192.168.56.101 2 server3 192.168.56.102 3 集群配置方式与上面两种方式类似，为方便操作可在每台机器上配置zookeeper的环境变量，每台机器上的配置文件也都相同。conf/zoo.cfg：1234567891011tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper/zookeeper-3.4.10/dataDirdataLogDir=/usr/local/zookeeper/zookeeper-3.4.10/dataLogDirclientPort=2182#server.id=host:port1:port2,其中id为server id,对应myid;host为ip或主机名称;port1为用于followers连接到leader的端口; port2为leader选举时使用的端口.server.1=192.168.56.100:2288:3388server.2=192.168.56.101:2288:3388server.3=192.168.56.102:2288:3388 在每台机器上的/usr/local/zookeeper/zookeeper-3.4.10/dataDir中创建myid文件，并写入server id：server1为1、server2为2、server3为3。 在每台机器上分别启动zk服务：1zkServer.sh start 3. 配置文件详解 3.1. conf/zoo_sample.cfg：zoo_sample.cfg为zookeeper的核心配置文件，需要将其修改为zoo.cfg。其中各个参数的解释如下： 3.1.1. Minimum Configuration（必要配置参数） 参数名 说明 tickTime 默认为2000。zk中基本时间单位长度（ms），zk中的时间都以该时间为基础，是该时间的倍数，如最小的session过期时间就是tickTime的两倍。服务器与服务器或客户端与服务器之间维持心跳的时间间隔，即每个tickTime会发送一个心跳，通过该心跳可以监视机器的工作状态、控制follower和leader的通信时间等。 dataDir 默认为/tmp/zookeeper。该默认目录仅为样例，不建议直接使用。存储快照文件snapshot的目录，即保存数据的目录，默认情况下，zk会将写数据的日志文件也存储在该目录。zk的数据在内存中以树形结构进行存储，而快照为每隔一段时间就会把整个DataTree的数据序列化后存储在磁盘中。 clientPort 默认为2181。客户端连接zk服务器的端口，zk会监听这个端口，接受客户端的访问请求。 3.1.2. Advanced Configuration（可选的高级配置项，更细化的控制）参数名说明dataLogDir（No Java system property）存储事务日志文件的目录。默认情况下在没有配置该参数时，zk会将事务日志和快照数据都存储在dataDir中，但是实际中最好将这两者的分开存储。因为当zk进行频繁读写操作时，会产生大量事务日志信息，将这两者分开存储可以提高性能，当然分不同磁盘进行存储可以进一步提高整体性能。在zk工作过程中，针对所有事务操作，在返回客户端“事务成功”的响应前，zk会保证已经将本次操作的事务日志写到磁盘上，只有这样，事务才会生效。globalOutstandingLimit默认为1000。（Java system property: zookeeper.globalOutstandingLimit）最大请求堆积数，即等待处理的最大请求数量的限制。当有很多客户端不断请求服务端时，可能导致请求堆积和内存耗尽，为避免这种情况，可通过设置该参数来限制同时处理的请求数。snapCount默认为100000。（Java system property: zookeeper.snapCount）用于配置相邻两次数据快照之间的事务操作次数，即ZooKeeper会在snapCount次事务操作（事务日志输出）之后进行一次数据快照。当新增log条数（事务日志）达到 snapCount/2 + Random.nextInt(snapCount/2) 时（log条数在[snapCount/2+1, snapCount]区间），将触发一次快照，此时zk会生成一个snapshot.*文件，同时创建一个新的事务日志文件log.*，同时log计数重置为0，以此循环。使用随机数的原因：让每个服务器生成快照的时间随机且可控，避免所有服务端同时生成快照（生成快照过程中将阻塞请求）。preAllocSize默认为64M，单位为KB。（Java system property: zookeeper.preAllocSize）用于配置zk事务日志文件预分配的磁盘空间大小。每当剩余空间小于4K时，将会再次预分配，如此循环。如果生成快照比较频繁时，可适当减小snapCount大小。比如，100次事务会新产生一个快照，新产生快照后会用新的事务日志文件，假设每次事务操作的数据量最多1KB，那么preAllocSize设置为1000KB即可。故而preAllocSize常与snapCount相关协调配置。maxClientCnxns默认为60。3.4.0版本之前默认为10。（No Java system property）限制单个客户端与单台服务器之间的并发连接数（在socket层级），根据IP区分不同的客户端。设置为0，可取消该限制。配置该参数可用来阻止某种类型的DoS攻击，包括文件描述符资源耗尽。clientPortAddress无默认值。New in 3.3.0。指定侦听clientPort的address（ipv4, ipv6 or hostname），默认情况下，clientPort会绑定到所有IP上。在物理server具有多个网络接口时，可以设置特定的IP。minSessionTimeoutmaxSessionTimeout默认为2*tickTime和20*tickTime。New in 3.3.0。（No Java system property）Session超时时间限制，如果客户端设置的超时时间不在这个范围（即2*tickTime~20*tickTime），那么会被强制设置为最大或最小时间。fsync.warningthresholdms默认为1000，单位为毫秒。New in 3.3.4。（ Java system property: zookeeper.fsync.warningthresholdms）当zk进行事务日志（WAL）fsync操作消耗的时间大于该参数，则在日志打印报警日志。autopurge.snapRetainCount默认为3。New in 3.4.0。（No Java system property）配置清理文件时需要保留的文件数目，会分别清理dataDir和dataLogDir目录下的文件。因为client与zk交换时会产生大量日志，且zk也会将内存数据存储为快照文件，这些数据不会自动删除，通过autopurge.snapRetainCount和autopurge.purgeInterval这两个参数搭配使用可以自动清理日志。autopurge.purgeInterval默认为0，单位为小时。New in 3.4.0。（No Java system property）清理频率，配置多少小时清理一次。需要填写一个大于等于1的整数，默认是0，表示不开启自动清理功能。若在集群处于忙碌的工作状态时开始自动清理，可能会影响zk集群性能，由于zk暂时无法设置时间段（在集群不忙的时候）来开启清理，故而有时会直接禁用该功能，通过在服务器上配置cron来进行清理操作。syncEnabled默认为true。New in 3.4.6, 3.5.0。（Java system property: zookeeper.observer.syncEnabled）观察者像参与者一样默认记录事务并将快照写入磁盘，这可以减少重新启动时观察者的恢复时间。可设置false来关闭该功能。 3.1.3. Cluster Options（集群控制参数） 参数名 说明 electionAlg默认为3。（No Java system property）配置zk的选举算法。“0”为基于原始的UDP的LeaderElection，“1”为基于UDP和无认证的的FastLeaderElection，“2”为基于UDP和认证的FastLeaderElection，“3”为基于TCP的FastLeaderElection。目前，0、1和2的选举算法的实现已经弃用，并有意从下个版本中移除，故而该参数应该用处不大了。initLimit默认为10。（No Java system property）集群中follower和leader之间初始连接时能容忍的最多心跳数（总时间长度即为10*2000=20000ms，即20s），当follower启动时会与leader建立连接并完成数据同步，leader允许follower在initLimit的心跳数内完成该工作。通常使用默认值即可，但是随着集群数据量的增大，follower启动时与leader的同步时间也会随之增大，使之可能无法在规定时间内完成数据同步，故而此情况下需适当调大该参数。leaderServes默认为yes。（Java system property: zookeeper.leaderServes）配置leader是否接受client连接请求。当zk集群超过3台机器，可以设置为“no”，让leader专注于协调集群中的机器，以提高集群性能。server.x=[hostname]:nnnnn[:nnnnn], etc（No Java system property）“server.id=host:port1:port2” 表示不同ZK服务器的配置。这里的id为server id，对应myid；host为ip或主机名称；port1为用于followers连接到leader的端口；port2为leader选举时使用的端口（当electionAlg为0时，port2不再必要）。若要在单台机器上测试搭建集群服务，需要设置不同的端口，避免端口冲突。syncLimit默认为5。（No Java system property）集群中follower和leader之间通信时能容忍的最多心跳数（总时间长度即为5*2000=10000ms，即10s），即follower和leader之间发送消息时请求和回应的最长时间不能超过syncLimit*tickTime毫秒。在集群工作时，leader会与所有follower进行心跳检测来确认存活状态，若leader在syncLimit*tickTime时间范围内没有收到响应，则认为follower已经掉线，无法和自己进行同步。当集群网络质量较差（如延时问题和丢包问题等），可适当调大该参数。group.x=nnnnn[:nnnnn]（No Java system property）对整个大的zk集群进行分组，x为组id，nnnnn是zk集群中各个服务id。如果你给集群中的实例分组的话，各个组之间不能有交集，并且要保证所有组的并集就是整个zk集群。若zk集群分为3组，只要其中两个是稳定的，整个集群状态即为稳定的（过半原则，有2n+1个组，只要有n+1个组是稳定状态，整个集群则为稳定状态）；选举leader时，每组为一票，当组内大多数投票，则投票成功。例子可见：http://zookeeper.apache.org/doc/current/zookeeperHierarchicalQuorums.htmlweight.x=nnnnn（No Java system property）常与group搭配使用，用于调节组内单个节点的权重。默认每个节点的权重为1，若为0则不参与选举。例子可见：https://www.jianshu.com/p/405f07b97550cnxTimeout默认为5，单位为秒。（Java system property: zookeeper.cnxTimeout）用于为leader选举通知打开连接的超时时间。仅在electionAlg的值为3时有用。4lw.commands.whitelist默认除了“wchp”和“wchc”之外的所有四字命令。New in 3.4.10。（Java system property: zookeeper.4lw.commands.whitelist）配置四字命令白名单，zk不处理未出现在list上的四字命令。多个以逗号分隔，如：4lw.commands.whitelist=stat, ruok, conf, isro；若需开启所有命令，则为4lw.commands.whitelist=*。ipReachableTimeout时间值，单位为毫秒。New in 3.4.11。（Java system property: zookeeper.ipReachableTimeout）配置当解析hostname时ip地址的可达超时时间。当解析hostname时，且hosts表和DNS服务中hostname对应着多个ip，则默认zk会使用第一个ip，且不会去检查可达性；而当该参数配置了一个大于0的值，zk则会依次判断hostname对应的所有ip是否可达（InetAddress.isReachable(long timeout)），若不可达，则判断下一个，若都不可达，则使用第一个ip。tcpKeepAlive默认为false。New in 3.4.11。（Java system property: zookeeper.tcpKeepAlive）配置用来选举的TCP连接是否为长连接。true为开启长连接。 3.1.4. Authentication &amp; Authorization Options（身份认证和相关授权的配置项） 参数名 说明 zookeeper.DigestAuthenticationProvider.superDigest默认禁用。New in 3.2。（Java system property only: zookeeper.DigestAuthenticationProvider.superDigest）允许zk集群管理员以“super”的身份来访问znode层级结构，且“super”用户没有ACL检查。“org.apache.zookeeper.server.auth.DigestAuthenticationProvider”可生成superDigest，其可通过调用参数“super:&lt;password>”来实现。在启动集群中每台服务器时，可提供生成的“super:&lt;data>”作为系统属性。zk客户端会传递一个“digest”和“super:&lt;password>”认证数据进行身份认证。需要注意，认证数据会以普通文本（明文）的形式传递给服务器，建议仅在本地（非网络中）和加密连接中使用。isroNew in 3.4.0。检查server是否处于只读状态。当回复“ro”时，代表在只读模式；当回复“rw”时，代表在非只读模式（可读可写）。gtmk获取当前10进制64位有符号数值形式的trace mask。stmk设置当前的trace mask。trace mask是为64位，每一位的标识表示开启或禁用server上特定类别的跟踪日志记录。Log4J必须设置为TRACE级别以看到trace日志信息。trace mask的每一位的含义如下：0b0000000000：保留位，留以后用。0b0000000010：记录client的请求, 不包括ping请求。0b0000000100：保留位，留以后用。0b0000001000：记录client的ping请求。0b0000010000：记录当前leader的信息，不包括ping请求。0b0000100000：记录client sessions的创建、移除和认证。0b0001000000：记录向client sessions传递的监控事件。0b0100000000： 保留位，留以后用。0b1000000000： 保留位，留以后用。默认的trace mask为0b0100110010。调用stmk命令时, server会将设置后的trace mask以十进制数值的形式返回回来。一个使用perl调用stmk命令的例子：$ perl -e &quot;print &#39;stmk&#39;, pack(&#39;q&gt;&#39;, 0b0011111010)&quot; | nc localhost 2181250 3.1.5. Experimental Options/Features（实验性配置项） 参数名 说明 Read Only Mode Server 默认为false。New in 3.4.0。（Java system property: readonlymode.enabled）配置为true，zk启用只读模式服务支持。在这种模式下，ROM clients仍然可以从zk读取值，但是不能写入值并查看来自其他客户机的更改。更多细节参见ZOOKEEPER-784。 3.1.6. Unsafe Options（不安全配置项） 参数名 说明 forceSync（Java system property: zookeeper.forceSync）默认情况下，zk要求先更新事务日志，再执行事务操作。若该参数设置为no，zk将不再需要等更新完事务日志后再执行事务操作。jute.maxbuffer（Java system property: jute.maxbuffer）配置可在一个znode中存储数据的最大容量。默认为0xfffff，或低于1M。注意若变更此值，所有server都要同步修改。skipACL（Java system property: zookeeper.skipACL）配置跳过ACL检查。这可以提高吞吐量，但会对所有人开放完全访问数据树，很不安全。quorumListenOnAllIPs若设置为true，zk服务将监听所有本地可用的ip地址，不仅仅是配置文件中server list。它会影响处理ZAB协议和 Fast Leader Election协议的连接。默认为false。 3.1.7. Communication using the Netty framework（使用Netty框架进行通信）Netty是一个基于NIO的客户机/服务器通信框架，它简化了(通过直接使用NIO) java应用程序网络级通信的许多复杂性。此外，Netty框架内置了对加密(SSL)和身份验证(证书)的支持。这些都是可选的功能，可以单独打开或关闭。在版本3.4之前，ZooKeeper一直都是直接使用NIO，但是在版本3.4及以后的版本中，Netty作为NIO(替换)的选项得到了支持。NIO仍然是默认值，但是基于Netty的通信可以通过将环境变量“zookeeper.serverCnxnFactory”设置为“org.apache.zookeeper.server.NettyServerCnxnFactory”来代替NIO。您可以在客户端或服务器上设置此项，或者两者都设置。 参考资料[1] Zookeeper Overview. http://zookeeper.apache.org/doc/r3.4.10/zookeeperOver.html.[2] ZooKeeper Administrator’s Guide. http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_configuration.[3] zookeeper调优(遇到就添加）. https://my.oschina.net/u/3049601/blog/1809785.[4] zookeeper日志各类日志简介. https://www.cnblogs.com/jxwch/p/6526271.html.[5] ZooKeeper: 简介, 配置及运维指南. https://www.cnblogs.com/neooelric/p/9230967.html.[6] ZooKeeper学习第二期–ZooKeeper安装配置. https://www.cnblogs.com/sunddenly/p/4018459.html.]]></content>
      <categories>
        <category>zookeeper系列</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
</search>
